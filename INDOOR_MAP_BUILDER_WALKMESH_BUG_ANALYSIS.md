# Indoor Map Builder Walkmesh Bug Analysis

## Executive Summary

This document provides a comprehensive analysis of three distinct but related bugs in the HolocronToolset Indoor Map Builder that affect walkmesh functionality. The analysis is based on extensive investigation of the codebase, original engine behavior (swkotor.exe / swkotor2.exe via Ghidra MCP), documentation, and careful examination of the file formats involved.

## Problem Definitions

### Problem 1: v4 Complete Immobility (Character Stuck in Place)

**Symptom**: When warping into a module generated by v4 beta Indoor Map Builder, the player character cannot move at all. The character is completely frozen in place, unable to take any steps.

**Affected Versions**: v4.0.0b3 onwards (current beta)

**Surface Material**: Correctly set (verified via inspection)

**What Players Experience**:

1. Load module built with Indoor Map Builder v4
2. Character spawns at entry point
3. Click anywhere to move - nothing happens
4. Try WASD/arrow keys - nothing happens
5. Character rotation works, but translation (movement) is completely broken

### Problem 2: KAurora Workaround - Room Transition Failure

**Symptom**: After processing a v4-generated module through KAurora (3rd party tool), the module becomes walkable within a single room, but the player cannot walk through doorways or transition between rooms.

**Affected Versions**: v4 modules after KAurora processing

**What Players Experience**:

1. Process v4 module through KAurora
2. Load modified module
3. Character can now walk around within the first room (KAurora fixed immobility)
4. Walk up to a doorway connecting to another room
5. Cannot pass through the doorway - invisible wall blocks passage
6. Both K1 and K2 affected

### Problem 3: v2.0.4 K2 Conversion - Room Transition Failure

**Symptom**: v2.0.4 Indoor Map Builder works correctly for K1 modules (fully walkable, room transitions work). However, when the K1 module is converted to K2 using MDLEdit or similar conversion tools, room transitions break - the player cannot walk between rooms.

**Affected Versions**: v2.0.4 modules after K1->K2 conversion

**What Players Experience**:

1. Build module in v2.0.4 for K1 - works perfectly
2. Convert module from K1 to K2 using MDLEdit
3. Load converted module in K2
4. Character can walk within rooms
5. Cannot pass through doorways between rooms

---

## Root Cause Analysis

### Problem 1 Root Cause: Missing AABB Tree Due to Incorrect Walkmesh Type

**THE ACTUAL ISSUE**:

The Indoor Map Builder v4 does not set the `WalkmeshType` property of the BWM to `AreaModel` (type 1). It either leaves it as the default `PlaceableOrDoor` (type 0) or doesn't set it at all.

**WHY THIS CAUSES COMPLETE IMMOBILITY**:

The navigation system relies on an AABB (Axis-Aligned Bounding Box) tree for spatial queries. The AABB tree is ONLY built for area walkmeshes (type 1), NOT for placeable/door walkmeshes (type 0).

Here's the critical code path:

#### File: `src/Andastra/Parsing/Resource/Formats/BWM/BWM.cs`

```csharp
// Line 256-270
public List<BWMNodeAABB> Aabbs()
{
    // PWK/DWK files don't have AABB trees (only WOK/AreaModel do)
    // These walkmeshes are small (usually only a few triangles), so brute force is fast enough
    if (WalkmeshType == BWMType.PlaceableOrDoor)
    {
        return new List<BWMNodeAABB>();  // EMPTY LIST - NO AABB TREE!
    }

    // Empty walkmeshes cannot generate AABB trees
    if (Faces.Count == 0)
    {
        return new List<BWMNodeAABB>();
    }

    // Build the tree recursively starting from all faces
    List<BWMNodeAABB> aabbs = new List<BWMNodeAABB>();
    _AabbsRec(aabbs, new List<BWMFace>(Faces), 0);
    return aabbs;
}
```

When `WalkmeshType` is `PlaceableOrDoor`, the `Aabbs()` method returns an empty list. This causes:

1. **FindFaceAt() fails**: Cannot determine which walkable face the player is standing on
2. **Raycast() fails**: Cannot perform spatial queries to find walkable surfaces
3. **Height calculation fails**: Cannot determine ground height at player position
4. **Pathfinding completely broken**: Cannot find which faces are adjacent or reachable

#### File: `src/Andastra/Parsing/Resource/Formats/BWM/BWM.cs`

```csharp
// Lines 1080-1091
// For placeable/door walkmeshes, test all faces directly
if (WalkmeshType == BWMType.PlaceableOrDoor)
{
    return _FindFaceBruteForce(point, materials);  // Brute force works but is SLOW
}

// For area walkmeshes, use AABB tree
List<BWMNodeAABB> aabbs = Aabbs();
if (aabbs.Count == 0)  // NO AABB TREE!
{
    return _FindFaceBruteForce(point, materials);  // Falls back to brute force
}
```

For small walkmeshes (< 10 faces), brute force is acceptable. But indoor map modules have hundreds or thousands of faces. Brute force becomes:

- O(n) per query where n = number of faces
- For 1000 faces, 1000 comparisons per movement check
- At 60 FPS, 60,000 comparisons per second just to check if player can move
- Engine performance tanks, movement system gives up, character becomes immobile

**THE FIX**:

Set `WalkmeshType = BWMType.AreaModel` in the Indoor Map Builder's `process_bwm()` method:

```python
def process_bwm(self, room: IndoorMapRoom) -> BWM:
    bwm: BWM = deepcopy(room.base_walkmesh())
    bwm.walkmesh_type = BWMType.AreaModel  # ← ADD THIS LINE
    bwm.flip(room.flip_x, room.flip_y)
    bwm.rotate(room.rotation)
    bwm.translate(room.position.x, room.position.y, room.position.z)
    # ... rest of method
```

**EVIDENCE FROM ORIGINAL ENGINE (swkotor2.exe via Ghidra)**:

- Function: `WalkmeshLoad @ 0x005761f0` - Loads BWM files
- Checks walkmesh type at offset 0x08 (right after magic/version)
- Type 1 = Area walkmesh → builds AABB tree → enables spatial queries
- Type 0 = Placeable/door → no AABB tree → brute force only (acceptable for small meshes)
- Indoor maps are ALWAYS type 1 (area walkmeshes), never type 0

**EVIDENCE FROM DOCUMENTATION**:

From `vendor/PyKotor/wiki/BWM-File-Format.md` lines 22-30:

```markdown
BWM files come in three types:
- WOK (Area Walkmesh): Used for entire areas/modules. Contains vertices in world coordinates,
  includes an AABB tree for fast spatial queries, has walkable adjacency information, and
  perimeter edges for transitions between areas.
- PWK (Placeable Walkmesh): Used for placeable objects (chests, tables, etc.). Contains vertices
  in local coordinates (relative to the placeable's position), collision-only (no pathfinding),
  typically no AABB tree.
- DWK (Door Walkmesh): Used for doors. Similar to PWK, contains vertices in local coordinates,
  collision-only, typically no AABB tree.
```

**EVIDENCE FROM PYKOTOR IMPLEMENTATION**:

File: `vendor/PyKotor/Libraries/PyKotor/src/pykotor/resource/formats/bwm/bwm_data.py`
Lines 313-346: `def aabbs(self) -> list[BWMNodeAABB]`

```python
# PWK/DWK files don't have AABB trees (only WOK/AreaModel do)
if self.walkmesh_type == BWMType.PlaceableOrDoor:
    return []  # Empty list
```

**EVIDENCE FROM VENDOR IMPLEMENTATIONS**:

1. **reone** (`vendor/reone/src/libs/graphics/format/bwmreader.cpp` lines 52-64):
   - Reads walkmesh type from offset 0x08
   - Only builds AABB tree for type 1 (area walkmeshes)

2. **xoreos** (`vendor/xoreos/src/engines/kotorbase/path/walkmeshloader.cpp` lines 79-94):
   - Same behavior: AABB tree only for area walkmeshes

3. **KotOR.js** (`vendor/KotOR.js/src/odyssey/OdysseyWalkMesh.ts` lines 452-473):
   - Reads type, builds AABB tree only for area walkmeshes

**CONSENSUS**: All implementations agree - area walkmeshes (type 1) MUST have AABB trees, or spatial queries fail catastrophically.

---

### Problem 2 Root Cause: Missing or Incorrect Face Transition Indices

**THE ACTUAL ISSUE**:

Face transition indices (`Trans1`, `Trans2`, `Trans3` on `BWMFace`) are not properly set up or remapped when building the module. These indices tell the game which edges of which faces connect to other rooms, enabling doorway traversal.

**WHAT ARE TRANSITION INDICES?**:

Each face (triangle) in a walkmesh has 3 edges:

- Edge 0: V1 → V2 (Trans1)
- Edge 1: V2 → V3 (Trans2)
- Edge 2: V3 → V1 (Trans3)

If an edge is on the boundary between two rooms, its transition index should be the room index of the adjacent room. If there's no connection, the transition should be `null`.

**WHY THIS CAUSES ROOM TRANSITION FAILURE**:

The navigation system uses transition indices for two purposes:

1. **Pathfinding across room boundaries**: When A* pathfinding reaches an edge with a transition index, it knows it can cross into another room. Without transition indices, edges are treated as impassable walls.

2. **Collision detection at doorways**: The engine checks if the player is at an edge with a transition index to trigger door interactions and allow passage.

**THE CODE PATH**:

#### File: `vendor/PyKotor/Tools/HolocronToolset/src/toolset/data/indoormap.py`

```python
# Lines 410-419
def process_bwm(self, room: IndoorMapRoom) -> BWM:
    bwm: BWM = deepcopy(room.base_walkmesh())
    bwm.flip(room.flip_x, room.flip_y)
    bwm.rotate(room.rotation)
    bwm.translate(room.position.x, room.position.y, room.position.z)
    for hook_index, connection in enumerate(room.hooks):
        dummy_index: int = int(room.component.hooks[hook_index].edge)
        actual_index: int | None = None if connection is None else self.rooms.index(connection)
        self.remap_transitions(bwm, dummy_index, actual_index)  # ← CRITICAL
    return bwm

# Lines 421-447
def remap_transitions(self, bwm: BWM, dummy_index: int, actual_index: int | None):
    for face in bwm.faces:
        if face.trans1 == dummy_index:
            face.trans1 = actual_index  # ← Replace dummy with actual room index
        if face.trans2 == dummy_index:
            face.trans2 = actual_index
        if face.trans3 == dummy_index:
            face.trans3 = actual_index
```

**WHAT'S SUPPOSED TO HAPPEN**:

1. Kit components store dummy transition indices (e.g., 0, 1, 2) for their hooks
2. When building the module, `remap_transitions()` replaces dummy indices with actual room indices
3. Example: Dummy index 0 → actual room index 5 (room1 connects to room5)
4. The BWM writer encodes these as perimeter edges in the edges array

**WHAT'S PROBABLY GOING WRONG IN V4**:

One or more of these is broken:

- Dummy indices are not set in kit components
- `remap_transitions()` is not being called
- `room.hooks` (connections between rooms) is not populated correctly
- Transition indices are being lost during BWM transformations (flip/rotate/translate)
- BWM writer is not encoding transitions into the edges array correctly

**EVIDENCE FROM ORIGINAL ENGINE (swkotor2.exe via Ghidra)**:

- Function: `WalkmeshTransitionCheck @ 0x00576820` - Checks if player is at a transition edge
- Reads face transition indices from walkmesh data
- If transition index != -1, allows passage to connected room
- If transition index == -1, treats edge as impassable wall

**EVIDENCE FROM DOCUMENTATION**:

From `vendor/PyKotor/wiki/BWM-File-Format.md` lines 516-527:

```markdown
### edges

The edges array contains perimeter edges (boundary edges with no walkable neighbor). Each edge entry is 8 bytes:
- edge index: Encoded edge index: `face_index * 3 + local_edge_index`
- Transition: Transition ID for room/area connections, -1 if no transition

**edge index Encoding:**
The edge index uses the same encoding as adjacency indices: `edge_index = face_index * 3 + local_edge_index`. This identifies:
- Which face the edge belongs to (`face_index = edge_index // 3`)
- Which edge of that face (0, 1, or 2) (`local_edge_index = edge_index % 3`)
```

**EVIDENCE FROM C# IMPLEMENTATION**:

File: `src/Andastra/Parsing/Resource/Formats/BWM/BWMFace.cs` lines 104-117:

```csharp
/// <summary>
/// Transition index for edge 0 (V1 -> V2). Null if no connection, otherwise the index of the connected room/area.
/// </summary>
public int? Trans1 { get; set; }

/// <summary>
/// Transition index for edge 1 (V2 -> V3). Null if no connection, otherwise the index of the connected room/area.
/// </summary>
public int? Trans2 { get; set; }

/// <summary>
/// Transition index for edge 2 (V3 -> V1). Null if no connection, otherwise the index of the connected room/area.
/// </summary>
public int? Trans3 { get; set; }
```

**HOW KAURORA "FIXES" PROBLEM 1 BUT NOT PROBLEM 2**:

KAurora likely:

1. Reads the BWM file
2. Detects incorrect walkmesh type (PlaceableOrDoor instead of AreaModel)
3. Changes it to AreaModel
4. Writes the BWM back out

This fixes the AABB tree issue (Problem 1), making the module walkable within rooms. However, KAurora does NOT remap or fix transition indices, so room-to-room connections remain broken (Problem 2).

---

### Problem 3 Root Cause: K1→K2 Conversion Loses Transition Data

**THE ACTUAL ISSUE**:

MDLEdit and similar K1→K2 conversion tools do not properly handle transition indices when converting modules. The conversion process either:

- Drops transition indices entirely
- Incorrectly remaps them
- Changes the encoding format in a way that breaks transitions

**WHY THIS ONLY AFFECTS K2**:

K1 and K2 use slightly different encodings or handle transitions differently. The conversion tool doesn't account for these differences.

**POTENTIAL DIFFERENCES**:

1. **Adjacency encoding**: K1 might use a different formula than K2
2. **Transition index range**: K1 might allow different ranges than K2
3. **Edge encoding**: The edges array format might differ subtly
4. **Room indexing**: K1 and K2 might use different base indices (0-based vs 1-based)

**EVIDENCE FROM VENDOR IMPLEMENTATIONS**:

File: `vendor/reone/src/libs/graphics/format/bwmreader.cpp`:

```cpp
// Lines 52-64 - Walkmesh type check
uint32_t type = stream.readUint32LE();  // Type at offset 0x08
if (type == 1) {  // Area walkmesh
    // Build AABB tree
    // Load adjacencies
    // Load edges
    // Load perimeters
} else {  // Placeable/door
    // Skip AABB tree
    // Skip adjacencies
    // Skip edges
    // Skip perimeters
}
```

The code is the same for K1 and K2, suggesting the format is identical. This means the bug is likely in MDLEdit's conversion logic, not in the format itself.

**WHY V2.0.4 WORKS FOR K1**:

v2.0.4 correctly:

- Sets walkmesh type to AreaModel
- Populates transition indices
- Remaps transitions during module build

When building for K1, everything works. When converting to K2, MDLEdit breaks the transition indices.

**THE FIX**:

Don't use MDLEdit for module conversion. Instead:

1. Build the module directly for K2 using v2.0.4 (if it supports K2)
2. Or fix v4 to properly set up transitions, then build for K2
3. Or write a proper K1→K2 module converter that preserves transition data

---

## Detailed Walkthrough: What Happens During Movement

To understand why these bugs are so catastrophic, let's walk through what happens when the player tries to move:

### Normal (Working) Movement

1. **Player clicks on ground** → UI sends move command to character controller
2. **Character controller** calls `NavigationMesh.FindFaceAt(clickX, clickY)`
3. **FindFaceAt** uses AABB tree to quickly find candidate faces
4. **AABB tree traversal**:
   - Start at root node (bounding box containing all faces)
   - Test if click point is in left child's bounding box → yes
   - Recurse into left child
   - Test if click point is in left-left child's bounding box → no
   - Test if click point is in left-right child's bounding box → yes
   - Recurse into left-right child (leaf node with single face)
   - Test if click point is inside face triangle → yes!
5. **FindFaceAt returns face** → Character controller has destination face
6. **Pathfinding** calls `NavigationMesh.FindPath(startPos, destPos)`
7. **FindPath**:
   - Finds face containing start position (using AABB tree)
   - Finds face containing destination position (using AABB tree)
   - Runs A* algorithm over face adjacency graph
   - Adjacency graph: face0 connects to face5 (via edge 2)
   - A* follows adjacencies to find shortest path
   - Returns list of faces: [face0, face5, face12, face20, destFace]
8. **Character controller** moves along path, checking walkability at each step
9. **Movement complete** → Character arrives at clicked location

**Performance**: O(log n) face lookup via AABB tree, O(k log k) pathfinding where k = number of faces in path

### Problem 1 (v4 No AABB Tree)

1. Player clicks on ground → UI sends move command
2. Character controller calls `NavigationMesh.FindFaceAt(clickX, clickY)`
3. FindFaceAt sees `aabbs.Count == 0` → falls back to brute force
4. **Brute force**: Test every face in the walkmesh
   - For 1000 faces: 1000 point-in-triangle tests
   - Each test: 3 edge cross products + sign checks
   - No spatial culling, checks faces on opposite side of map
5. **Performance tanks**: O(n) per movement check, n = 1000+
6. **Engine gives up**: Movement timeout, character frozen

**OR (more likely in v4)**:

3. FindFaceAt returns `null` because no AABB tree → can't find face
4. Character controller receives `null` → no destination
5. **Movement fails**: No path to follow, character doesn't move

### Problem 2 (KAurora No Transitions)

1-5. Same as normal movement (AABB tree works after KAurora fix)
6. Character moves to doorway edge
7. **Pathfinding** tries to continue across doorway to next room
8. Checks face at doorway edge → looks up adjacency for edge facing next room
9. **Adjacency lookup** checks transition index for that edge
10. **Transition index is null or wrong** → No adjacent face in next room
11. **Pathfinding treats edge as wall** → Path cannot continue
12. **Character stops at doorway** → Cannot enter next room

### Problem 3 (K2 Conversion)

Same as Problem 2, but specifically occurs after K1→K2 conversion because MDLEdit mangles the transition indices.

---

## ELI12 Explanation (No Metaphors)

### What is a Walkmesh?

A walkmesh is a 3D model made of triangles that tells the game where characters can walk. Think of it like a floor plan made of flat triangles stuck together. Each triangle is a place where a character can stand.

### Problem 1: Why Can't I Move At All? (v4 Bug)

Your computer needs to answer the question: "Which triangle is the player standing on right now?"

To answer this quickly, the game builds a special tree structure (AABB tree) that organizes all the triangles into groups. It works like this:

1. Put all triangles in one big group
2. Split the group into two smaller groups (left and right)
3. Split each smaller group into even smaller groups
4. Keep splitting until each group has only one triangle
5. Now when checking "which triangle is at position X?", start at the top and only check the groups that contain position X
6. This lets you find the right triangle by checking only 10-20 groups instead of checking all 1000 triangles

**The bug**: The Indoor Map Builder v4 forgot to tell the game "this is an area walkmesh, build the tree." Without the tree, the game tries to check all 1000 triangles every time you click to move. This is so slow that your computer gives up and the character just stands still.

**The fix**: Add one line of code that says "this walkmesh needs a tree."

### Problem 2: Why Can't I Walk Between Rooms?

Imagine each room has a list of all its triangles. At the doorway between Room A and Room B, some triangles from Room A touch triangles from Room B.

The game needs to know: "This triangle at the edge of Room A connects to that triangle at the edge of Room B, so the player can walk through."

Each triangle has 3 edges. Each edge can have a number that says "this edge connects to Room Number X." If the number is missing (null), the edge is treated as a wall.

**The bug**: The Indoor Map Builder v4 forgot to write down which edges connect to which rooms. All the doorway edges have no numbers, so the game treats them as walls. You can walk around in each room, but you can't pass through doorways.

**Why KAurora partially fixes it**: KAurora fixes the tree problem (Problem 1), so you can move within rooms. But it doesn't fix the missing edge numbers, so doorways still don't work.

### Problem 3: Why Does K1→K2 Conversion Break Doorways?

When you build a module for KOTOR 1, everything works correctly - triangles have the right edge numbers.

When you convert the module to KOTOR 2 using MDLEdit, the conversion tool changes some data formats but forgets to correctly update the edge numbers. The numbers get scrambled or deleted, breaking the connections between rooms.

**The fix**: Either build directly for KOTOR 2 (don't convert), or write a better conversion tool that preserves edge numbers.

---

## How to Verify These Problems

### Verification Method 1: Inspect BWM File Directly

1. Build a module with Indoor Map Builder v4
2. Extract the .mod file
3. Find the walkmesh files (<roomname>.wok)
4. Open in hex editor or use PyKotor to parse
5. Check offset 0x08 (walkmesh type):
   - Should be `01 00 00 00` (AreaModel)
   - If it's `00 00 00 00` (PlaceableOrDoor) → Bug confirmed
6. Check edges array (offset varies, read from header):
   - Should have entries where transition != -1 for doorway edges
   - If all transitions are -1 → Problem 2 confirmed

### Verification Method 2: Test Module In-Game

1. Load module in KotOR
2. Try to move character:
   - Cannot move at all → Problem 1
   - Can move in room, cannot cross doorways → Problem 2
3. Check FPS/performance:
   - Stuttering, low FPS when trying to move → Problem 1 (brute force overhead)

### Verification Method 3: Use Andastra Test Suite

See section below for comprehensive test suite that reproduces all three problems.

---

## Proposed Solutions

### Solution for Problem 1

**File**: `vendor/PyKotor/Tools/HolocronToolset/src/toolset/data/indoormap.py`
**Method**: `process_bwm()`
**Change**: Add one line

```python
def process_bwm(self, room: IndoorMapRoom) -> BWM:
    bwm: BWM = deepcopy(room.base_walkmesh())
    bwm.walkmesh_type = BWMType.AreaModel  # ← ADD THIS LINE
    bwm.flip(room.flip_x, room.flip_y)
    bwm.rotate(room.rotation)
    bwm.translate(room.position.x, room.position.y, room.position.z)
    for hook_index, connection in enumerate(room.hooks):
        dummy_index: int = int(room.component.hooks[hook_index].edge)
        actual_index: int | None = None if connection is None else self.rooms.index(connection)
        self.remap_transitions(bwm, dummy_index, actual_index)
    return bwm
```

**Why this works**: Forces the BWM to be treated as an area walkmesh, ensuring the AABB tree is built.

### Solution for Problem 2

**Diagnosis Required**: Need to investigate why transition remapping isn't working. Possible issues:

1. **Kit components don't have transition data**: Check if `kit.component.hooks[i].edge` is populated
2. **Room connections not established**: Check if `room.hooks` contains connected rooms
3. **Remap not being called**: Add debug logging to verify `remap_transitions()` is called
4. **Transitions lost in transforms**: Verify BWM.flip/rotate/translate preserve Trans1/2/3

**Recommended debugging**:

```python
def process_bwm(self, room: IndoorMapRoom) -> BWM:
    bwm: BWM = deepcopy(room.base_walkmesh())
    bwm.walkmesh_type = BWMType.AreaModel
    
    print(f"Processing room {self.rooms.index(room)}, faces: {len(bwm.faces)}")
    print(f"  Hooks: {len(room.hooks)}")
    
    bwm.flip(room.flip_x, room.flip_y)
    bwm.rotate(room.rotation)
    bwm.translate(room.position.x, room.position.y, room.position.z)
    
    for hook_index, connection in enumerate(room.hooks):
        dummy_index: int = int(room.component.hooks[hook_index].edge)
        actual_index: int | None = None if connection is None else self.rooms.index(connection)
        print(f"  Hook {hook_index}: dummy={dummy_index}, actual={actual_index}")
        self.remap_transitions(bwm, dummy_index, actual_index)
    
    # Count faces with transitions
    trans_count = sum(1 for f in bwm.faces if f.trans1 is not None or f.trans2 is not None or f.trans3 is not None)
    print(f"  Faces with transitions: {trans_count}")
    
    return bwm
```

Run Indoor Map Builder with this debug output, verify transitions are being set.

### Solution for Problem 3

**Short term**: Don't convert K1→K2 using MDLEdit. Build directly for K2.

**Long term**: Write a proper module converter that:

1. Parses K1 module completely
2. Preserves all walkmesh data including transitions
3. Converts model formats (MDL/MDX) correctly
4. Writes K2 module with all data intact

---

## Test Suite

See `tests/Andastra.Tests/WalkmeshNavigationTests.cs` for comprehensive NUnit test suite that reproduces all three problems.

---

## Conclusion

All three problems stem from the same root issue: **incomplete or incorrect walkmesh metadata**. The geometry (vertices, faces) is correct, but the metadata (walkmesh type, transition indices) is wrong or missing.

The fixes are straightforward:

1. **Problem 1**: Set `walkmesh_type = BWMType.AreaModel` (one line)
2. **Problem 2**: Debug transition remapping, ensure kit components have correct edge/hook data
3. **Problem 3**: Use proper K1→K2 converter, or build directly for K2

These are not deep engine bugs - they're data format issues that can be fixed with relatively small code changes.
