# HoloPatcher.NET Rules and Conventions for AI LLM agents

## ⚠️ CRITICAL: Git Commit Requirement ⚠️

**MANDATORY FOR ALL AI AGENTS**: After making ANY changes to files in this repository, you MUST:

1. **Stage all modified files**: `git add <file1> <file2> ...` (or `git add .` for all changes)
2. **Commit with a descriptive message**: `git commit -m "type: descriptive message"`
3. **Verify the commit succeeded**: Check that `git commit` returns successfully with no errors

**This is NOT optional.** Do NOT summarize changes without committing them. Do NOT skip this step. Every code change, file modification, or configuration update MUST be committed before you consider the task complete.

**NEVER use `git add .` or `git add -A` to stage changes.** Always stage files individually. This is because we may have multiple agents working on multiple files simultaneously.

**Commit message format**: Use conventional commits format:

- `fix:` for bug fixes
- `feat:` for new features
- `refactor:` for code refactoring
- `docs:` for documentation changes
- `chore:` for maintenance tasks
- `test:` for test changes

Example: `git commit -m "fix: correct finalize job condition in workflow"`

---

## Documentation

When creating ANY new `.md` files, always follow these guidelines:

- Always place within `docs`
- Never report on progression (changes and what still remains to be done).
- Exclusively provide public-facing documentation, something an end user will need to read if they want to either develop for PyKotor or work with it.

Please do not create .md documentation unless it delivers public-facing information or authoritative gameplay/platform references that an end user or developer genuinely needs for PyKotor or the games themselves.

## Helper Scripts

- Always place within `scripts`
- Should be idempotent and flexible enough to be used for a plethora of scenarios, not just whatever the task you're working on involves.
- Do not delete helper .py/.ps1/.sh scripts when you are finished with them; keep them in scripts folder

## File Organization

**CRITICAL: Repository Root Cleanup**

AI agents MUST maintain proper file organization in the repository root:

1. **Documentation Files**:
   - ALL `.md` documentation files (except `README.md`) MUST be placed in `./docs`
   - `README.md` is the ONLY markdown file allowed in the repository root
   - When creating new documentation, always place it in `./docs`
   - If you find documentation files in the root (other than `README.md`), move them to `./docs`

2. **Script Files**:
   - ALL script files (`.ps1`, `.sh`, `.py`, `.bat`, `.cmd`, etc.) MUST be placed in `./scripts`
   - When creating new scripts, always place them in `./scripts`
   - If you find script files in the root, move them to `./scripts`

3. **Root Directory**:
   - The root directory should only contain:
     - `README.md` (the only allowed markdown file in root)
     - Solution files (`.sln`)
     - Project configuration files (`.csproj`, `.props`, etc.)
     - Build artifacts and temporary files (as appropriate)
     - Essential configuration files (`.gitignore`, `.cursorrules`, etc.)

**When creating or moving files, always verify they are in the correct location according to these rules.**

## C# Language Version Requirements

**CRITICAL: The maximum C# language version allowed is 7.3. NEVER upgrade to C# 8.0 or higher.**

This is a hard requirement for .NET Framework 4.x compatibility. The following C# 8+ features are FORBIDDEN:

- Nullable reference types (`string?`, `object?`, etc.)
- Switch expressions
- Using declarations (must use `using` blocks)
- Default interface implementations
- Async streams
- Indices and ranges (`^1`, `..`)
- Null-coalescing assignment (`??=`)
- Pattern matching enhancements (property patterns, tuple patterns, positional patterns)
- Static local functions

When fixing code, convert C# 8+ syntax to C# 7.3 compatible alternatives, including but not limited to:

- `string?` → `string` (use `[CanBeNull]` attribute if needed and add `using JetBrains.Annotations;` if not already present)
- `value!` → `value` (remove null-forgiving operator)
- Switch expressions → switch statements
- `using var x = ...` → `using (var x = ...) { }`
- `namespace SomeNamespace;` → `namespace SomeNamespace { ... }`

## 1:1 Porting Requirements

When porting code from Python (vendor/PyKotor) to C#:

1. **Exact Code Matching**: All code must match the Python source 1:1, including:
   - Logic and control flow
   - Variable names (converted to C# naming conventions where necessary)
   - Comments (exact text, no additional comments)
   - Whitespace structure (where applicable)

2. **Comments**:
   - DO NOT add explanatory comments about how Python works
   - DO NOT add comments explaining the conversion
   - DO NOT add "1:1 port" comments
   - DO NOT add "TODO" comments unless they exist in Python
   - ONLY include comments that exist in the Python source
   - Match comment text exactly, including docstrings

3. **No Additional Code**:
   - DO NOT add helper methods unless they exist in Python
   - DO NOT add validation unless it exists in Python
   - DO NOT add error handling unless it exists in Python
   - DO NOT add optimizations unless they exist in Python

4. **Assumptions**:
   - If Python tests pass, the Python implementation is correct
   - If C# tests fail, the C# code does not match Python
   - Fix failures by matching Python exactly, not by "improving" the code

5. **File Structure**:
   - Match Python file organization where possible
   - Match class/method organization where possible

6. **Error Messages**:
   - Match Python error messages exactly (converted to C# string formatting)

## Testing

- All ported tests must pass
- Failing tests indicate the C# code does not match Python
- Fix by matching Python exactly, not by changing test expectations

## Matching Implementations

**CRITICAL: Source Lookup & Commenting**

Before making ANY edit to ANY file, you MUST locate the corresponding source code in the `vendor` directory to ensure 1:1 parity.

1. **Identify the Source of Truth**:
   - **General Logic / Compiler**: Use `vendor/PyKotor` (e.g., `Libraries/PyKotor/...`).
   - **Decompiler (NCS -> NSS)**: Use `vendor/DeNCS` or `vendor/NCSDecomp`. **IGNORE PyKotor** for decompilation logic.

2. **Add Precise Reference Comments**:
   Every ported method or logic block MUST have a comment with:
   - **EXACT Relative Path**: Path to the source file (e.g., `Libraries/PyKotor/src/pykotor/extract/twoda.py`).
   - **EXACT Line Numbers**: Specific line number or range.
   - **Code Snippet**: Include 1-2 lines of the ORIGINAL source code to prove you checked it.

   **Format**:

   ```csharp
   // Matching PyKotor implementation at Libraries/PyKotor/src/pykotor/module/module.py:45
   // Original: self._name = name
   this._name = name;
   ```

## Running PyKotor Python Code

**CRITICAL: Virtual Environment Setup for Python Execution**

When running ANY Python code or tests in `vendor/PyKotor`, you MUST use the following pattern to ensure the correct virtual environment is activated and environment variables are loaded:

**PowerShell Command Pattern**:

```powershell
cd <workspace_path>/vendor/PyKotor; & "<workspace_path>/vendor/PyKotor/.venv_3.13/Scripts/Activate.ps1"; Get-Content .env | ForEach-Object { if ($_ -match '^([^#][^=]*)=(.*)$') { Set-Item -Path "env:$($matches[1])" -Value $matches[2] } }; <your_python_command>
```

**Components Explained**:

1. **Change Directory**: `cd <workspace_path>/vendor/PyKotor` - Changes to the PyKotor directory
2. **Activate Virtual Environment**: `& "<workspace_path>/vendor/PyKotor/.venv_3.13/Scripts/Activate.ps1"` - Activates the Python virtual environment (the `&` operator executes the script in PowerShell)
3. **Load Environment Variables**: `Get-Content .env | ForEach-Object { if ($_ -match '^([^#][^=]*)=(.*)$') { Set-Item -Path "env:$($matches[1])" -Value $matches[2] } }` - Parses the `.env` file and loads environment variables (skips comment lines, extracts KEY=VALUE pairs)
4. **Execute Python Command**: Your actual Python command (e.g., `python -m pytest Libraries/PyKotor/tests/resource/formats/test_ncs.py -v --tb=short 2>&1`)

**Examples**:

- Running pytest: Replace `<your_python_command>` with `python -m pytest Libraries/PyKotor/tests/resource/formats/test_ncs.py -v --tb=short 2>&1`
- Running a Python script: Replace `<your_python_command>` with `python path/to/script.py`
- Running a Python module: Replace `<your_python_command>` with `python -m module.name`

**IMPORTANT**: Always replace `<workspace_path>` with the actual workspace root path (e.g., `G:\GitHub\HoloPatcher.NET`). All commands are chained with semicolons (`;`) to execute as a single PowerShell command.

## NCS/NSS File Operations

The `scripts` directory contains a comprehensive unified PowerShell tool for all NCS/NSS file operations:

### NcsTool.ps1

Unified tool for all NCS (bytecode) and NSS (source) file operations. Supports multiple operations via subcommands:

**Operations:**

- `compile`: Compile NSS source files to NCS bytecode
- `decompile`: Decompile NCS bytecode files to NSS source
- `compare`: Compare two NCS files (bytecode and/or instructions)
- `roundtrip`: Perform round-trip testing (NSS -> NCS -> NSS -> NCS -> Compare)
- `generate-defs`: Generate ScriptDefs.cs from nwscript.nss files

**Examples:**

```powershell
# Compile NSS to NCS
.\scripts\NcsTool.ps1 compile -InputPath "script.nss" -Game "k2"
.\scripts\NcsTool.ps1 compile -InputPath "C:\Scripts" -Recursive -LibraryLookup "C:\Includes" -Overwrite

# Decompile NCS to NSS
.\scripts\NcsTool.ps1 decompile -InputPath "script.ncs" -OutputPath "script.nss" -Game "k1"
.\scripts\NcsTool.ps1 decompile -InputPath "C:\NCS" -OutputPath "C:\Decompiled" -Recursive

# Compare two NCS files
.\scripts\NcsTool.ps1 compare -OriginalFile "original.ncs" -RoundTripFile "roundtrip.ncs" -CompareMode "bytecode" -Detailed
.\scripts\NcsTool.ps1 compare -OriginalFile "test.ncs" -RoundTripFile "test.rt.ncs" -CompareMode "both" -ShowOnly "both"

# Round-trip testing
.\scripts\NcsTool.ps1 roundtrip -InputPath "script.nss" -Game "k2"
.\scripts\NcsTool.ps1 roundtrip -InputPath "C:\Scripts" -Recursive -CompareMode "bytecode" -KeepIntermediate -StopOnFirstFailure

# Generate ScriptDefs.cs
.\scripts\NcsTool.ps1 generate-defs
```

The tool supports `-WhatIf` for dry-run testing, `-Verbose` for detailed output, and follows PowerShell best practices. It can process single files, multiple files, or entire directory trees recursively.

## NCSDecomp.NET - External Compiler Prohibition

**CRITICAL: ABSOLUTE PROHIBITION OF EXTERNAL COMPILERS**

**FOR NCSDecomp.NET ONLY**: Under NO circumstances should NCSDecomp.NET use external compilers, especially NOT `nwnnsscomp.exe` or any other external compiler tool.

**The entire purpose of NCSDecomp.NET is to implement its own self-contained compiler/decompiler.**

**This means:**

- DO NOT call `nwnnsscomp.exe` from NCSDecomp.NET code
- DO NOT invoke any external compiler executables
- DO NOT use `CompilerUtil`, `NWScriptLocator`, or any compiler wrapper classes
- DO NOT implement compiler execution methods (`externalCompile`, `externalDecompile`, etc.)
- DO NOT depend on external compiler availability for decompilation to work
- NCSDecomp.NET must be completely self-contained and functional without any external tools

**Note**: This restriction applies ONLY to `src/NCSDecomp` and `src/CSharpKOTOR/Formats/NCS/NCSDecomp`. Other parts of HoloPatcher.NET (e.g., tests, round-trip validation utilities) MAY use external compilers, but the core decompiler library must NOT.

**If you see code in NCSDecomp.NET that calls external compilers, it should be removed or refactored to use internal implementations only.**

## Odyssey Engine Development

**CRITICAL: Ghidra MCP Usage for Engine-Related Code**

When working on Odyssey Engine code (anything in `src/OdysseyRuntime/`), AI agents MUST:

1. **Use Ghidra MCP** for understanding original engine behavior:
   - The Ghidra MCP server has `swkotor2.exe` loaded
   - Use `mcp_ghidra_*` tools to search functions, decompile code, find strings
   - Search for relevant strings to locate engine functions (e.g., "BWM", "pathfind", "walkmesh")
   - Verify implementation faithfulness against original engine behavior

2. **Reference Documentation**:
   - Primary: `vendor/PyKotor/wiki/` for file format documentation
   - Secondary: `vendor/PyKotor/vendor/xoreos-docs/` for official BioWare specs
   - Implementation plan: `.cursor/plans/stride_odyssey_engine_e8927e4a.plan.md`
   - Roadmap: `docs/engine_roadmap.md`

3. **Clean-Room Process**:
   - Derive behavior from observation and specs, not code copying
   - Match original engine behavior exactly where documented
   - Document any deviations or improvements

4. **Code Organization**:
   - `Odyssey.Core` - Pure domain, no Stride dependency
   - `Odyssey.Content` - Asset conversion/caching
   - `Odyssey.Scripting` - NCS VM + NWScript API
   - `Odyssey.Kotor` - K1/K2 specific rules
   - `Odyssey.Stride` - Stride rendering adapters
   - `Odyssey.Game` - Executable launcher

5. **Maintain C# 7.3 Compatibility**: Even in OdysseyRuntime projects

### Engine Architecture Principles

**Layered Architecture** (strict separation):

```
┌─────────────────────────────────────────────────────────────┐
│                    Odyssey.Game (Executable)                │
├─────────────────────────────────────────────────────────────┤
│  Odyssey.Stride     │  Odyssey.Kotor      │  Odyssey.Content│
│  (Rendering)        │  (Game Rules)       │  (Asset Pipeline)│
├─────────────────────────────────────────────────────────────┤
│                    Odyssey.Scripting (NCS VM)               │
├─────────────────────────────────────────────────────────────┤
│                    Odyssey.Core (Domain)                    │
├─────────────────────────────────────────────────────────────┤
│                    CSharpKOTOR (File Formats)               │
└─────────────────────────────────────────────────────────────┘
```

**Dependency Rules**:

- `Odyssey.Core` MUST NOT reference Stride, CSharpKOTOR.Formats, or game-specific code
- `Odyssey.Scripting` MUST NOT reference Stride
- `Odyssey.Content` may reference CSharpKOTOR for format parsing
- `Odyssey.Stride` may reference Stride and Odyssey.Core
- `Odyssey.Kotor` may reference all Odyssey.* except Odyssey.Game

**Dependency Direction**:

- Core → (nothing external)
- Content → Core, CSharpKOTOR
- Scripting → Core
- Kotor → Core, Content, Scripting
- Stride → Core, Content, Kotor (adapter layer)
- Game → All

**No Game Assets**: The runtime must load from user-provided KOTOR/TSL installation. Never ship game assets.

### Implementation Order (Dependency-First)

When implementing features, follow this order to avoid rework:

1. Foundation: projects, config, Stride window
2. Resource provider: wrap CSharpKOTOR.Installation
3. Content cache: texture/model decode
4. Area rendering: LYT + VIS + room meshes
5. Walkmesh: collision + navigation
6. Entity spawn: GIT parsing
7. NCS VM: script execution
8. Engine API: NWScript function implementations
9. Transitions: doors, triggers, modules
10. Dialogue: DLG/TLK/VO
11. Combat: attack resolution, HP
12. Save/Load: state persistence

### Game Loop Implementation

Follow this fixed-timestep game loop pattern (60 Hz simulation):

```csharp
// Per-frame phases (execute in order)
1. Input Phase      // Collect input, update camera, click-to-move
2. Script Phase     // Process delay wheel, heartbeats, action queues
3. Simulation Phase // Entity positions, perception, combat rounds
4. Animation Phase  // Skeletal animations, particles, lip sync
5. Scene Sync Phase // Runtime transforms → Stride scene graph
6. Render Phase     // VIS culling, transparency sort, draw calls
7. Audio Phase      // Spatial audio positions, trigger one-shots
```

### NCS VM Implementation Requirements

When implementing NCS VM features:

- **Header validation**: `"NCS "` + `"V1.0"` signature, `0x42` marker at offset 8
- **Instructions start**: At offset `0x0D`
- **Endianness**: All multi-byte values are **big-endian**
- **Stack alignment**: 4-byte aligned, vectors are 12 bytes (3 floats)
- **Jump offsets**: Relative to **instruction start**, not next instruction
- **ACTION arguments**: `uint16 routineId` + `uint8 argCount` (stack elements, not bytes)
- **STORE_STATE**: Stores stack/locals bytes for DelayCommand semantics

### Engine API Implementation

When implementing NWScript engine functions:

1. **Use ScriptDefs**: Reference `CSharpKOTOR.Common.Script.ScriptDefs` for function signatures
2. **Profile separation**: K1 has ~850 functions, K2 has ~950 functions
3. **Incremental coverage**: Start with minimal set for boot/movement, expand by feature
4. **Return conventions**: Follow exact return type semantics (void, int, float, object, etc.)

**Do NOT implement all NWScript functions alphabetically.** Implement by usage tiers:

- **Tier 0**: Boot/Basic (~50 functions) - PrintString, Random, GetTag, GetLocal*, etc.
- **Tier 1**: Movement/Actions (~80 functions) - ActionMove*, AssignCommand, DelayCommand
- **Tier 2**: Creatures/Stats (~100 functions) - GetAbilityScore, GetCurrentHitPoints
- **Tier 3**: Combat (~80 functions) - ActionAttack, EffectDamage, ApplyEffectToObject
- **Tier 4**: Dialogue (~40 functions) - SpeakString, GetPCSpeaker, BeginConversation
- **Tier 5**: Inventory (~60 functions) - GetItemInSlot, CreateItemOnObject
- **Tier 6**: Force Powers (~50 functions) - ActionCastSpellAtObject, GetHasSpell

### Entity/Component System

Follow these patterns for entity implementation:

```csharp
// Object type hierarchy
Object (abstract base)
├── Creature (PC, NPC)
├── Door
├── Placeable
├── Trigger (invisible volume)
├── Waypoint (invisible marker)
├── Sound (ambient emitter)
├── Store (merchant)
├── Encounter (spawn point)
├── Item (world-dropped or inventory)
└── AreaOfEffect (spell zones)
```

**GFF Template Loading**:

- UTC → Creature entity + components
- UTP → Placeable entity + components
- UTD → Door entity + components
- UTT → Trigger entity + components (polygon geometry)
- UTW → Waypoint entity
- UTS → Sound emitter entity
- UTE → Encounter spawner entity
- UTI → Item (BaseItem, Properties, Charges)

### Walkmesh Implementation

BWM format requirements:

- Type 1 (WOK): Area walkmesh with AABB tree, adjacency, perimeter edges
- Type 0 (PWK/DWK): Placeable/door walkmesh with hook vectors
- Adjacency encoding: `adjacency = faceIndex * 3 + edgeIndex`, `-1` = no neighbor
- Decode adjacency: `face = encoded / 3`, `edge = encoded % 3`
- Surface materials: Lookup via `surfacemat.2da` for walkability

### Combat System

Combat follows round-based model (~3 second rounds):

```
Round States:
Starting    (0.0s)  - Init animations
FirstAttack (~0.5s) - Primary attack
SecondAttack(~1.5s) - Offhand/counter (if duel)
Cooldown    (~2.5s) - Return to ready
Finished    (3.0s)  - Complete
```

D20 attack resolution:

- Natural 20 = always hit (check for crit)
- Natural 1 = always miss
- Roll + attack bonus >= target AC = hit

### File Format References

When implementing format handling, reference these CSharpKOTOR parsers:

- NCS: `CSharpKOTOR/Formats/NCS/` - NWScript bytecode
- BWM: `CSharpKOTOR/Formats/BWM/` - Walkmesh (WOK/PWK/DWK)
- LYT: `CSharpKOTOR/Formats/LYT/` - Area layout
- VIS: `CSharpKOTOR/Formats/VIS/` - Room visibility
- MDL/MDX: `CSharpKOTOR/Formats/MDL/` - Models/animations
- TPC/TXI: `CSharpKOTOR/Formats/TPC/` - Textures
- DLG: `CSharpKOTOR/Formats/DLG/` - Dialogue
- GIT: `CSharpKOTOR/Formats/GIT/` - Instance spawning
- GFF templates: UTC, UTP, UTD, UTT, UTW, UTS, UTE, UTI

### Future Engine Support (Aurora Family)

The architecture supports future engines via abstraction:

| Engine | Games | Notes |
|--------|-------|-------|
| Odyssey | KotOR 1/2 | Current focus |
| Aurora | NWN | Similar NCS, different rendering |
| Electron | Jade Empire | Modified NCS |
| Eclipse | Dragon Age | Different script system |

**Engine Family Abstraction** (for future Aurora/Eclipse support):

```csharp
public interface IGameProfile
{
    string GameId { get; }
    int ScriptFunctionCount { get; }
    IResourceLayout ResourceLayout { get; }
    IRuleSet RuleSet { get; }
}
```

Design for extensibility to other engines:

- Keep `IGameProfile` interface for game-specific behavior
- Game rules in `Odyssey.Kotor`, not `Odyssey.Core`
- Resource paradigms (GFF, archives, scripting) shared
- Game-specific 2DA/rules are pluggable

### Key Files to Reference

| Subsystem | Reference Files |
|-----------|-----------------|
| VM Implementation | `Odyssey.Scripting/VM/NcsVm.cs` |
| Navigation | `Odyssey.Core/Navigation/NavigationMesh.cs` |
| Actions | `Odyssey.Core/Actions/*.cs` |
| Entity System | `Odyssey.Core/Entities/Entity.cs`, `World.cs` |
| Format Parsing | `CSharpKOTOR/Formats/*` |
| Full Plan | `.cursor/plans/stride_odyssey_engine_e8927e4a.plan.md` |
| Roadmap | `docs/engine_roadmap.md` |

### Key 2DA Tables

| Table | Purpose |
|-------|---------|
| `appearance.2da` | Model resref, walk/run speed |
| `baseitems.2da` | Item categories, damage |
| `feat.2da` | Feat definitions |
| `spells.2da` | Force powers |
| `classes.2da` | Class progression |
| `surfacemat.2da` | Surface walkability |

### Clean-Room Process

- Implementation is derived from behavioral observation and specification documents
- **No code copying** from other implementations
- Match original engine behavior exactly where documented
- Document any deviations or improvements
- Avoid GPL/LGPL/AGPL dependencies in shipped runtime

### Testing Requirements

- NCS VM: deterministic unit tests for all opcodes
- Resource precedence: synthetic mini-installation fixtures
- Content decoding: golden-file tests
- Vertical slice: playable integration tests

### Performance Budgets

- Module load (warm): seconds, not minutes
- Frame rate: stable 60fps on midrange GPU
- Script budget: capped instructions per frame
- Memory: bounded caches with LRU eviction

### Definition of Done for Engine Work

A feature is complete when:

- Implementation matches original engine behavior
- Unit tests pass for deterministic logic
- Integration with CSharpKOTOR format parsers works
- No C# 8+ syntax used
- Code compiles with no warnings
