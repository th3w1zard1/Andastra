# HoloPatcher.NET Rules and Conventions for AI LLM agents

## ⚠️ CRITICAL: Git Commit Requirement ⚠️

**MANDATORY FOR ALL AI AGENTS**: After making ANY changes to files in this repository, you MUST:

1. **Stage all modified files**: `git add <file1> <file2> ...` (or `git add .` for all changes)
2. **Commit with a descriptive message**: `git commit -m "type: descriptive message"`
3. **Verify the commit succeeded**: Check that `git commit` returns successfully with no errors

**This is NOT optional.** Do NOT summarize changes without committing them. Do NOT skip this step. Every code change, file modification, or configuration update MUST be committed before you consider the task complete.

**NEVER use `git add .` or `git add -A` to stage changes.** Always stage files individually. This is because we may have multiple agents working on multiple files simultaneously.

**Commit message format**: Use conventional commits format:

- `fix:` for bug fixes
- `feat:` for new features
- `refactor:` for code refactoring
- `docs:` for documentation changes
- `chore:` for maintenance tasks
- `test:` for test changes

Example: `git commit -m "fix: correct finalize job condition in workflow"`

---

## Documentation

When creating ANY new `.md` files, always follow these guidelines:

- Always place within `docs`
- Never report on progression (changes and what still remains to be done).
- Exclusively provide public-facing documentation, something an end user will need to read if they want to either develop for Andastra.NET or work with it.

Please do not create .md documentation unless it delivers public-facing information or authoritative gameplay/platform references that an end user or developer genuinely needs for PyKotor or the games themselves.

## Helper Scripts

- Always place within `scripts`
- Should be idempotent and flexible enough to be used for a plethora of scenarios, not just whatever the task you're working on involves.
- Do not delete helper .py/.ps1/.sh scripts when you are finished with them; keep them in scripts folder

## File Organization

**CRITICAL: Repository Root Cleanup**

AI agents MUST maintain proper file organization in the repository root:

1. **Documentation Files**:
   - ALL `.md` documentation files (except `README.md`) MUST be placed in `./docs`
   - `README.md` is the ONLY markdown file allowed in the repository root
   - When creating new documentation, always place it in `./docs`
   - If you find documentation files in the root (other than `README.md`), move them to `./docs`

2. **Script Files**:
   - ALL script files (`.ps1`, `.sh`, `.py`, `.bat`, `.cmd`, etc.) MUST be placed in `./scripts`
   - When creating new scripts, always place them in `./scripts`
   - If you find script files in the root, move them to `./scripts`

3. **Root Directory**:
   - The root directory should only contain:
     - `README.md` (the only allowed markdown file in root)
     - Solution files (`.sln`)
     - Project configuration files (`.csproj`, `.props`, etc.)
     - Build artifacts and temporary files (as appropriate)
     - Essential configuration files (`.gitignore`, `.cursorrules`, etc.)

**When creating or moving files, always verify they are in the correct location according to these rules.**

## C# Language Version Requirements

**CRITICAL: The maximum C# language version allowed is 7.3. NEVER upgrade to C# 8.0 or higher.**

This is a hard requirement for .NET Framework 4.x compatibility. The following C# 8+ features are FORBIDDEN:

- Nullable reference types (`string?`, `object?`, etc.)
- Switch expressions
- Using declarations (must use `using` blocks)
- Default interface implementations
- Async streams
- Indices and ranges (`^1`, `..`)
- Null-coalescing assignment (`??=`)
- Pattern matching enhancements (property patterns, tuple patterns, positional patterns)
- Static local functions

When fixing code, convert C# 8+ syntax to C# 7.3 compatible alternatives, including but not limited to:

- `string?` → `string` (use `[CanBeNull]` attribute if needed and add `using JetBrains.Annotations;` if not already present)
- `value!` → `value` (remove null-forgiving operator)
- Switch expressions → switch statements
- `using var x = ...` → `using (var x = ...) { }`
- `namespace SomeNamespace;` → `namespace SomeNamespace { ... }`

## NCS/NSS File Operations

The `scripts` directory contains a comprehensive unified PowerShell tool for all NCS/NSS file operations:

### NcsTool.ps1

Unified tool for all NCS (bytecode) and NSS (source) file operations. Supports multiple operations via subcommands:

**Operations:**

- `compile`: Compile NSS source files to NCS bytecode
- `decompile`: Decompile NCS bytecode files to NSS source
- `compare`: Compare two NCS files (bytecode and/or instructions)
- `roundtrip`: Perform round-trip testing (NSS -> NCS -> NSS -> NCS -> Compare)
- `generate-defs`: Generate ScriptDefs.cs from nwscript.nss files

**Examples:**

```powershell
# Compile NSS to NCS
.\scripts\NcsTool.ps1 compile -InputPath "script.nss" -Game "k2"
.\scripts\NcsTool.ps1 compile -InputPath "C:\Scripts" -Recursive -LibraryLookup "C:\Includes" -Overwrite

# Decompile NCS to NSS
.\scripts\NcsTool.ps1 decompile -InputPath "script.ncs" -OutputPath "script.nss" -Game "k1"
.\scripts\NcsTool.ps1 decompile -InputPath "C:\NCS" -OutputPath "C:\Decompiled" -Recursive

# Compare two NCS files
.\scripts\NcsTool.ps1 compare -OriginalFile "original.ncs" -RoundTripFile "roundtrip.ncs" -CompareMode "bytecode" -Detailed
.\scripts\NcsTool.ps1 compare -OriginalFile "test.ncs" -RoundTripFile "test.rt.ncs" -CompareMode "both" -ShowOnly "both"

# Round-trip testing
.\scripts\NcsTool.ps1 roundtrip -InputPath "script.nss" -Game "k2"
.\scripts\NcsTool.ps1 roundtrip -InputPath "C:\Scripts" -Recursive -CompareMode "bytecode" -KeepIntermediate -StopOnFirstFailure

# Generate ScriptDefs.cs
.\scripts\NcsTool.ps1 generate-defs
```

The tool supports `-WhatIf` for dry-run testing, `-Verbose` for detailed output, and follows PowerShell best practices. It can process single files, multiple files, or entire directory trees recursively.

## NCSDecomp.NET - External Compiler Prohibition

**CRITICAL: Ghidra MCP Usage for Andastra Code (Aurora/Eclipse/Infinity/Odyssey)**

When working on Andastra Engine code (anything in `src/Andastra/`), AI agents MUST:

1. **Use Ghidra MCP** for understanding original engine behavior:
   - **ALL executables loaded in Ghidra** are assumed to be BioWare engine games and are necessary for reverse engineering
   - Use `mcp_ghidra_*` tools to discover, search, and analyze functions across ALL loaded executables
   - Search for relevant strings to locate engine functions (e.g., "BWM", "pathfind", "walkmesh", "GLOBALVARS", "PARTYTABLE")
   - Verify implementation faithfulness against original engine behavior
   - **MANDATORY: Cross-Engine Analysis and Inheritance Structure**:
     - **NEVER document a function without specifying which .exe it's from** (e.g., `swkotor2.exe: 0x004eb750`, `nwmain.exe: 0x14051d5c0`)
     - **CRITICAL: Base Class Implementation Workflow**:
       - **NEVER implement or document base classes (Runtime.Games.Common) until ALL engines have been reverse engineered**
       - **MANDATORY WORKFLOW for base classes**:
         1. **FIRST**: Search for and analyze equivalent functions in ALL engines (swkotor.exe, swkotor2.exe, nwmain.exe, daorigins.exe, DragonAge2.exe, MassEffect.exe, MassEffect2.exe)
         2. **SECOND**: Decompile and compare implementations across ALL engines to identify common patterns
         3. **THIRD**: Document findings in Ghidra for ALL engines with function addresses and analysis
         4. **FOURTH**: Only after complete cross-engine analysis, identify what is truly common across ALL engines
         5. **FIFTH**: Implement base class with ONLY common functionality (no engine-specific details)
         6. **SIXTH**: Implement engine-specific subclasses with engine-specific details
       - **Base classes MUST NOT contain**:
         - Engine-specific function addresses (e.g., `swkotor2.exe: 0x004eb750`)
         - Engine-specific implementation details
         - References to engine-specific file formats or systems
         - Any details that differ between engines
       - **Base classes MUST ONLY contain**:
         - Abstract methods/properties that all engines share
         - Common initialization patterns (if identical across all engines)
         - Shared interfaces and contracts
         - Generic documentation that applies to all engines
       - **Engine-specific details MUST be in subclasses**:
         - All Ghidra function addresses go in engine-specific subclasses
         - All engine-specific implementation details go in subclasses
         - All engine-specific file format references go in subclasses
     - **MANDATORY**: When finding ANY function in ANY engine, AI agents MUST:
       1. Search for similar/equivalent functions in ALL other engines (swkotor.exe, swkotor2.exe, nwmain.exe, daorigins.exe, DragonAge2.exe, MassEffect.exe, etc.)
       2. Decompile and compare implementations across engines to identify common patterns
       3. Document findings in Ghidra for ALL engines before implementing base classes
       4. Establish base class inheritance structure:
          - Create base classes in `Runtime.Games.Common` for shared functionality (ONLY after complete cross-engine analysis)
          - Create engine-specific implementations in `Runtime.Games.{Engine}` that inherit from base classes
          - Document which functions map to base class methods vs. engine-specific overrides
       5. Document inheritance structure in roadmap with format (example):

          ```
          Base Class: `CommonScriptExecutor` (Runtime.Games.Common)
          - Odyssey: `OdysseyScriptExecutor : CommonScriptExecutor` (swkotor.exe: 0x..., swkotor2.exe: 0x...)
          - Aurora: `AuroraScriptExecutor : CommonScriptExecutor` (nwmain.exe: 0x...)
          - Eclipse: `EclipseScriptExecutor : CommonScriptExecutor` (daorigins.exe: 0x..., DragonAge2.exe: 0x...)
          ```

     - **MANDATORY**: When modifying ANY code in `src/Andastra/`, AI agents MUST:
       - **For base classes (Runtime.Games.Common)**:
         - MUST reverse engineer ALL engines first (Odyssey, Aurora, Eclipse)
         - MUST compare implementations across ALL engines
         - MUST only document common functionality (no engine-specific details)
         - MUST NOT include engine-specific function addresses or implementation details
       - **For engine-specific subclasses (Runtime.Games.{Engine})**:
         - Search Ghidra for related functions using string searches and function name searches in the relevant engine executable(s)
         - Decompile relevant functions to understand original implementation
         - Add detailed comments with Ghidra function addresses, executable name, and context
         - Use consistent comment format matching the MonoGame API documentation pattern
         - **ALWAYS specify the source executable** in comments (e.g., `swkotor2.exe: 0x004eb750`)
       - **PRIORITY**: When working on base classes, prioritize reverse engineering Aurora and Eclipse engines FIRST (they are less documented than Odyssey)
   - **MANDATORY: In-Ghidra Documentation**: AI agents MUST document findings directly within Ghidra using Ghidra MCP tools:
     - Use `mcp_ghidra_set_decompiler_comment` to add comments to decompiled code
     - Use `mcp_ghidra_set_disassembly_comment` to add comments to assembly code
     - Use `mcp_ghidra_rename_function` and `mcp_ghidra_rename_function_by_address` to give functions intuitive, descriptive names
     - Use `mcp_ghidra_rename_data` to rename data labels with meaningful names
     - Use `mcp_ghidra_rename_variable` to rename local variables for clarity
     - Use `mcp_ghidra_set_function_prototype` to set accurate function signatures
     - Use `mcp_ghidra_set_local_variable_type` to set correct variable types
     - **Documentation must be comprehensive**: Every analyzed function should have:
       - Descriptive function name (not `FUN_004eb750`, but `SaveGlobalVariables` or similar)
       - Function prototype with correct parameter types and return types
       - Comments explaining what the function does, its purpose, and key implementation details
       - Renamed variables and data labels that reflect their actual purpose
       - Cross-references documented where relevant
   - **MANDATORY: Progress Tracking in Ghidra**: AI agents MUST track reverse engineering progress directly within Ghidra:
     - Use comments to mark functions as "ANALYZED", "PARTIALLY_ANALYZED", "TODO", or "IMPLEMENTED"
     - Document what has been implemented in C# code and what remains to be done
     - Use consistent comment prefixes for tracking (e.g., `[STATUS: ANALYZED]`, `[STATUS: TODO]`, `[C#: IMPLEMENTED]`)
     - Document relationships between functions (call chains, data flow, etc.) in comments
     - Track which functions are critical vs. auxiliary
     - Document any deviations or improvements made in the C# implementation compared to the original
   - **Optimal Ghidra Usage**: AI agents MUST use Ghidra tools canonically and optimally:
     - Always rename functions with descriptive, intuitive names that reflect their purpose
     - Set accurate function prototypes to improve decompilation quality
     - Use proper data types for variables and parameters
     - Create bookmarks or use comments to organize related functions
     - Document string references and their usage patterns
     - Track cross-references (xrefs) to understand function relationships
     - Use Ghidra's analysis features to their fullest potential
     - Maintain consistency in naming conventions across all analyzed executables

2. **Reference Documentation**:
   - Primary: `vendor/PyKotor/wiki/` for file format documentation
   - Secondary: `vendor/PyKotor/vendor/xoreos-docs/` for official BioWare specs
   - Implementation plan: `.cursor/plans/monogame_odyssey_engine_e8927e4a.plan.md`
   - Roadmap: `docs/engine_roadmap.md`

3. **CRITICAL: External API Documentation Research**:
   When implementing ANY external API usage (MonoGame, .NET Framework, third-party libraries) in `src/Andastra/`, AI agents MUST:

   **Required Workflow**:
   1. **Search**: Use `mcp_context7_get-library-docs`, `mcp_firecrawl_firecrawl_search`, `mcp_tavily_tavily-search`, or `web_search` to find official API documentation
   2. **Verify**: Cross-reference with at least one additional authoritative source (official docs, GitHub, Stack Overflow with verified answers)
   3. **Document**: Add comments above the code with:
      - Clear explanation of what the code does
      - Exact API method signature/parameters
      - Full URL to official documentation
      - Any relevant implementation notes

   **Comment Format**:

   ```csharp
   // Brief description of operation
   // Based on [Library] API: [Full URL to official documentation]
   // Method signature: MethodName(ParamType1, ParamType2, ...)
   // Implementation note: [if applicable]
   actualCodeHere();
   ```

   **Example**:

   ```csharp
   // Begin sprite batch
   // Based on MonoGame API: https://docs.monogame.net/api/Microsoft.Xna.Framework.Graphics.SpriteBatch.html
   // Begin(SpriteSortMode, BlendState, SamplerState, DepthStencilState, RasterizerState, Effect, Matrix?)
   // SpriteSortMode.Deferred batches all draw calls for efficiency
   _spriteBatch.Begin(SpriteSortMode.Deferred, BlendState.AlphaBlend);

   // Access viewport from GraphicsDevice.Viewport
   // Based on MonoGame documentation: https://docs.monogame.net/api/Microsoft.Xna.Framework.Graphics.Viewport.html
   var viewport = GraphicsDevice.Viewport;
   ```

   **Requirements**:
   - ALL URLs must be verified and accessible (test before committing)
   - URLs must point to official documentation, not third-party tutorials
   - Comments must explain the "what" and "why", not just reference the URL
   - Use Context7 for library docs, Firecrawl/Tavily for web search, web_search as fallback

4. **CRITICAL: Ghidra MCP Documentation for Engine Code**:
   When implementing or modifying ANY code in `src/Andastra/`, AI agents MUST:

   **Required Workflow**:
   1. **Search**: Use `mcp_ghidra_list_strings`, `mcp_ghidra_search_functions_by_name`, `mcp_ghidra_list_functions`, or `mcp_ghidra_get_xrefs_to` to find relevant engine functions across ALL loaded executables
   2. **Decompile**: Use `mcp_ghidra_decompile_function_by_address` or `mcp_ghidra_decompile_function` to understand original implementation
   3. **Document IN GHIDRA FIRST**: Before documenting in C# code, AI agents MUST:
      - Rename functions in Ghidra with descriptive names using `mcp_ghidra_rename_function` or `mcp_ghidra_rename_function_by_address`
      - Set function prototypes using `mcp_ghidra_set_function_prototype` with accurate parameter and return types
      - Rename variables and data labels using `mcp_ghidra_rename_variable` and `mcp_ghidra_rename_data`
      - Set variable types using `mcp_ghidra_set_local_variable_type`
      - Add comprehensive comments in Ghidra using `mcp_ghidra_set_decompiler_comment` and `mcp_ghidra_set_disassembly_comment`
      - Document function purpose, parameters, return values, and key implementation details
      - Track analysis status and implementation progress in comments
      - Document relationships and cross-references
   4. **Document in C# Code**: After documenting in Ghidra, add comments above the C# code with:
      - Clear explanation of what the code does
      - Ghidra executable name and function address (hex format, e.g., `swkotor2.exe: 0x004eb750`)
      - Function name from Ghidra (should be descriptive, not `FUN_004eb750`)
      - Key implementation details from decompiled code
      - String references used to locate the function (e.g., "GLOBALVARS", "PARTYTABLE")

   **Comment Format**:

   ```csharp
   // Brief description of operation
   // Based on swkotor2.exe: SerializeSaveNfo @ 0x004eb750
   // Located via string reference: "savenfo" @ 0x007be1f0
   // Cross-engine: Similar functions in swkotor.exe: 0x..., nwmain.exe: 0x..., daorigins.exe: 0x...
   // Inheritance: Base class SaveSerializer (Runtime.Games.Common), Odyssey override (Runtime.Games.Odyssey)
   // Original implementation: [key detail from decompiled code]
   actualCodeHere();
   ```

   **Example Workflow**:

   **Step 1: Search and Analyze in Ghidra**
   - Use `mcp_ghidra_list_strings` with filter "GLOBALVARS" to find string references
   - Use `mcp_ghidra_get_xrefs_to` to find functions that reference the string
   - Decompile the function to understand its implementation

   **Step 2: Document in Ghidra**
   - Rename function: `mcp_ghidra_rename_function_by_address("0x005ac670", "SaveGlobalVariables")`
   - Set prototype: `mcp_ghidra_set_function_prototype("0x005ac670", "void SaveGlobalVariables(char* saveName)")`
   - Add comment: `mcp_ghidra_set_decompiler_comment("0x005ac670", "[STATUS: ANALYZED]\n[C#: IMPLEMENTED]\nSaves global variables to GFF format.\nConstructs path 'SAVES:\\{saveName}\\GLOBALVARS', writes GFF with global variable state.\nLocated via string reference: 'GLOBALVARS' @ 0x007c27bc")`
   - Rename variables and data labels as needed

   **Step 3: Document in C# Code**

   ```csharp
   // Save global variables to GFF format
   // Based on swkotor2.exe: SaveGlobalVariables @ 0x005ac670
   // Located via string reference: "GLOBALVARS" @ 0x007c27bc
   // Original implementation: Constructs path "SAVES:\{saveName}\GLOBALVARS", writes GFF with global variable state
   private void SaveGlobalVariables(SaveGameData saveData)
   {
       // Implementation...
   }

   // Serialize save metadata to NFO GFF format
   // Based on swkotor2.exe: SerializeSaveNfo @ 0x004eb750
   // Located via string reference: "savenfo" @ 0x007be1f0
   // Original implementation: Creates GFF with "NFO " signature, writes SAVEGAMENAME, TIMEPLAYED, AREANAME, etc.
   public byte[] SerializeSaveNfo(SaveGameData saveData)
   {
       // Implementation...
   }
   ```

   **Requirements**:
   - ALL function addresses must be verified in Ghidra (use `mcp_ghidra_decompile_function_by_address`)
   - Functions MUST be renamed in Ghidra with descriptive names before documenting in C# code
   - Function prototypes MUST be set in Ghidra for accurate decompilation
   - Comprehensive comments MUST be added in Ghidra before documenting in C# code
   - Include string references that were used to locate the function
   - Include key implementation details from decompiled code
   - Track analysis and implementation status in Ghidra comments
   - Comments must explain the "what" and "why", not just reference the address
   - Use natural language and intuitive terminology relevant to the task
   - Be concise but thorough - provide enough context to find the function in Ghidra
   - C# code comments should reference the renamed function name from Ghidra, not generic names like `FUN_004eb750`
   - **ALWAYS specify the source executable** in all documentation (roadmap, comments, etc.)
   - **ALWAYS establish inheritance structure** when documenting functions across multiple engines

5. **Clean-Room Process**:
   - Derive behavior from observation and specs, not code copying
   - Match original engine behavior exactly where documented
   - Document any deviations or improvements

6. **Code Organization**:
   - `Runtime.Core` - Pure domain, no MonoGame dependency
   - `Runtime.Content` - Asset conversion/caching
   - `Runtime.Scripting` - NCS VM + NWScript API
   - `Runtime.Games.Common` - Common abstractions for all engines
   - `Runtime.Games.{Engine}` - Engine-specific implementations (Odyssey, Aurora, Eclipse, Infinity)
   - `Runtime.Graphics` - MonoGame rendering adapters
   - `Game` - Executable launcher

7. **Maintain C# 7.3 Compatibility**: Even in Andastra projects

### Engine Architecture Principles

**Layered Architecture** (strict separation):

```
┌─────────────────────────────────────────────────────────────┐
│                    Game (Executable)                         │
├─────────────────────────────────────────────────────────────┤
│  Graphics   │  Games.{Engine}      │  Content                │
│  (Rendering)│  (Engine Rules)      │  (Asset Pipeline)       │
├─────────────────────────────────────────────────────────────┤
│                    Scripting (NCS VM)                       │
├─────────────────────────────────────────────────────────────┤
│                    Core (Domain)                             │
├─────────────────────────────────────────────────────────────┤
│                    Parsing (File Formats)                   │
└─────────────────────────────────────────────────────────────┘
```

**Dependency Rules**:

- `Runtime.Core` MUST NOT reference MonoGame, Parsing, or engine-specific code
- `Runtime.Scripting` MUST NOT reference MonoGame
- `Runtime.Content` may reference Parsing for format parsing
- `Runtime.Graphics` may reference MonoGame and Runtime.Core
- `Runtime.Games.{Engine}` may reference Core, Content, Scripting, Games.Common
- `Runtime.Games.Common` may reference Core only

**Dependency Direction**:

- Core → (nothing external)
- Content → Core, Parsing
- Scripting → Core
- Games.Common → Core
- Games.{Engine} → Core, Content, Scripting, Games.Common
- Graphics → Core, Content, Games.Common
- Game → All

**No Game Assets**: Runtime loads from user-provided game installations. Never ship game assets.

### Implementation Order (Dependency-First)

When implementing features, follow this order to avoid rework:

1. Foundation: projects, config, MonoGame window
2. Resource provider: wrap Andastra.Installation
3. Content cache: texture/model decode
4. Area rendering: LYT + VIS + room meshes
5. Walkmesh: collision + navigation
6. Entity spawn: GIT parsing
7. NCS VM: script execution
8. Engine API: NWScript function implementations
9. Transitions: doors, triggers, modules
10. Dialogue: DLG/TLK/VO
11. Combat: attack resolution, HP
12. Save/Load: state persistence

### Game Loop Implementation

Follow this fixed-timestep game loop pattern (60 Hz simulation):

```csharp
// Per-frame phases (execute in order)
1. Input Phase      // Collect input, update camera, click-to-move
2. Script Phase     // Process delay wheel, heartbeats, action queues
3. Simulation Phase // Entity positions, perception, combat rounds
4. Animation Phase  // Skeletal animations, particles, lip sync
5. Scene Sync Phase // Runtime transforms → MonoGame rendering structures
6. Render Phase     // VIS culling, transparency sort, draw calls
7. Audio Phase      // Spatial audio positions, trigger one-shots
```

### NCS VM Implementation Requirements

When implementing NCS VM features:

- **Header validation**: `"NCS "` + `"V1.0"` signature, `0x42` marker at offset 8
- **Instructions start**: At offset `0x0D`
- **Endianness**: All multi-byte values are **big-endian**
- **Stack alignment**: 4-byte aligned, vectors are 12 bytes (3 floats)
- **Jump offsets**: Relative to **instruction start**, not next instruction
- **ACTION arguments**: `uint16 routineId` + `uint8 argCount` (stack elements, not bytes)
- **STORE_STATE**: Stores stack/locals bytes for DelayCommand semantics

### Engine API Implementation

When implementing NWScript engine functions:

1. **Use ScriptDefs**: Reference `Andastra.Common.Script.ScriptDefs` for function signatures
2. **Profile separation**: K1 has ~850 functions, K2 has ~950 functions
3. **Incremental coverage**: Start with minimal set for boot/movement, expand by feature
4. **Return conventions**: Follow exact return type semantics (void, int, float, object, etc.)

Design for extensibility across engine families (Odyssey, Aurora, Eclipse, Infinity):

### Clean-Room Process

- Implementation is derived from behavioral observation and specification documents
- **No code copying** from other implementations
- Match original engine behavior exactly where documented
- Document any deviations or improvements
- Avoid GPL/LGPL/AGPL dependencies in shipped runtime

### Testing Requirements

- NCS VM: deterministic unit tests for all opcodes
- Resource precedence: synthetic mini-installation fixtures
- Content decoding: golden-file tests
- Vertical slice: playable integration tests

### Performance Budgets

- Module load (warm): seconds, not minutes
- Frame rate: stable 60fps on midrange GPU
- Script budget: capped instructions per frame
- Memory: bounded caches with LRU eviction

### Definition of Done for Engine Work

A feature is complete when:

- Implementation matches original engine behavior
- Unit tests meticulously written, and passing for deterministic logic
- Integration with Andastra format parsers works
- C# 7.3 syntax or lower, 8+ isn't supported.
- Code compiles with no warnings
