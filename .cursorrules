# HoloPatcher.NET Rules and Conventions for AI LLM agents

## ‚ö†Ô∏è CRITICAL: Git Commit Requirement ‚ö†Ô∏è

**MANDATORY FOR ALL AI AGENTS**: After making ANY changes to files in this repository, you MUST:

1. **Stage all modified files**: `git add <file1> <file2> ...` (or `git add .` for all changes)
2. **Commit with a descriptive message**: `git commit -m "type: descriptive message"`
3. **Verify the commit succeeded**: Check that `git commit` returns successfully with no errors

**This is NOT optional.** Do NOT summarize changes without committing them. Do NOT skip this step. Every code change, file modification, or configuration update MUST be committed before you consider the task complete.

**NEVER use `git add .` or `git add -A` to stage changes.** Always stage files individually. This is because we may have multiple agents working on multiple files simultaneously.

**Commit message format**: Use conventional commits format:

- `fix:` for bug fixes
- `feat:` for new features
- `refactor:` for code refactoring
- `docs:` for documentation changes
- `chore:` for maintenance tasks
- `test:` for test changes

Example: `git commit -m "fix: correct finalize job condition in workflow"`

Note: root-level .git is different repo than ./src/Andastra/.git

---

## Documentation

When creating ANY new `.md` files, always follow these guidelines:

- Always place within `docs`
- Never report on progression (changes and what still remains to be done).
- Exclusively provide public-facing documentation, something an end user will need to read if they want to either develop for Andastra.NET or work with it.

Please do not create .md documentation unless it delivers public-facing information or authoritative gameplay/platform references that an end user or developer genuinely needs for PyKotor or the games themselves.

## Helper Scripts

- Always place within `scripts`
- Should be idempotent and flexible enough to be used for a plethora of scenarios, not just whatever the task you're working on involves.
- Do not delete helper .py/.ps1/.sh scripts when you are finished with them; keep them in scripts folder

## File Organization

**CRITICAL: Repository Root Cleanup**

AI agents MUST maintain proper file organization in the repository root:

1. **Documentation Files**:
   - ALL `.md` documentation files (except `README.md`) MUST be placed in `./docs`
   - `README.md` is the ONLY markdown file allowed in the repository root
   - When creating new documentation, always place it in `./docs`
   - If you find documentation files in the root (other than `README.md`), move them to `./docs`

2. **Script Files**:
   - ALL script files (`.ps1`, `.sh`, `.py`, `.bat`, `.cmd`, etc.) MUST be placed in `./scripts`
   - When creating new scripts, always place them in `./scripts`
   - If you find script files in the root, move them to `./scripts`

3. **Root Directory**:
   - The root directory should only contain:
     - `README.md` (the only allowed markdown file in root)
     - Solution files (`.sln`)
     - Project configuration files (`.csproj`, `.props`, etc.)
     - Build artifacts and temporary files (as appropriate)
     - Essential configuration files (`.gitignore`, `.cursorrules`, etc.)

**When creating or moving files, always verify they are in the correct location according to these rules.**

## Cross-Platform Target Framework Requirements

**CRITICAL: All projects must be cross-platform compatible. Use platform-agnostic target frameworks only.**

- **DO use**: `net9.0`, `net8.0`, `net7.0` (no platform suffix)
- **DO NOT use**: `net9.0-windows`, `net9.0-linux`, `net9.0-macos` (platform-specific TFMs are forbidden)

This codebase must run on Windows, Linux, and macOS. Platform-specific TFMs break cross-platform compatibility and are not allowed under any circumstances.

## C# Language Version Requirements

**CRITICAL: The maximum C# language version allowed is 7.3. NEVER upgrade to C# 8.0 or higher.**

This is a hard requirement for .NET Framework 4.x compatibility. The following C# 8+ features are FORBIDDEN:

- Nullable reference types (`string?`, `object?`, etc.)
- Switch expressions
- Using declarations (must use `using` blocks)
- Default interface implementations
- Async streams
- Indices and ranges (`^1`, `..`)
- Null-coalescing assignment (`??=`)
- Pattern matching enhancements (property patterns, tuple patterns, positional patterns)
- Static local functions

When fixing code, convert C# 8+ syntax to C# 7.3 compatible alternatives, including but not limited to:

- `string?` ‚Üí `string` (use `[CanBeNull]` attribute if needed and add `using JetBrains.Annotations;` if not already present)
- `value!` ‚Üí `value` (remove null-forgiving operator)
- Switch expressions ‚Üí switch statements
- `using var x = ...` ‚Üí `using (var x = ...) { }`
- `namespace SomeNamespace;` ‚Üí `namespace SomeNamespace { ... }`

## Incomplete/Temporary Code Marking

**CRITICAL: All incomplete code MUST use `TODO:` prefix for searchability.**

**Marking Patterns:**

- **STUB**: Method signature exists, throws `NotImplementedException` with context

  ```csharp
  // TODO: STUB - Implement ProcessData (swkotor2.exe: 0x004eb750)
  throw new NotImplementedException("ProcessData: Reverse engineering in progress");
  ```

- **PLACEHOLDER**: Temporary implementation that works but needs replacement

  ```csharp
  // TODO: PLACEHOLDER - Replace with full GFF serialization (swkotor2.exe: 0x005ac670)
  ```

- **SIMPLIFIED**: Working implementation missing features/optimizations

  ```csharp
  // TODO: SIMPLIFIED - Add A* pathfinding optimization for large areas
  ```

- **FIXME**: Known bug or incorrect behavior requiring fix

  ```csharp
  // TODO: FIXME - Memory leak when disposing resources, needs investigation
  ```

- **HACK**: Workaround that should be replaced with proper solution

  ```csharp
  // TODO: HACK - Using reflection until API is fixed
  ```

**Requirements:**

- ALL incomplete code MUST start with `TODO:` followed by type (STUB/PLACEHOLDER/SIMPLIFIED/FIXME/HACK)
- Include context: what needs doing, why incomplete, relevant addresses/refs
- For reverse-engineered code: include executable and function address
- Be specific: avoid vague comments like "fix this" or "placeholder"
- Public APIs: use XML docs (`/// <summary>`) to document incomplete methods

## NCS/NSS File Operations

The `scripts` directory contains a comprehensive unified PowerShell tool for all NCS/NSS file operations:

### NcsTool.ps1

Unified tool for all NCS (bytecode) and NSS (source) file operations. Supports multiple operations via subcommands:

**Operations:**

- `compile`: Compile NSS source files to NCS bytecode
- `decompile`: Decompile NCS bytecode files to NSS source
- `compare`: Compare two NCS files (bytecode and/or instructions)
- `roundtrip`: Perform round-trip testing (NSS -> NCS -> NSS -> NCS -> Compare)
- `generate-defs`: Generate ScriptDefs.cs from nwscript.nss files

**Examples:**

```powershell
# Compile NSS to NCS
.\scripts\NcsTool.ps1 compile -InputPath "script.nss" -Game "k2"
.\scripts\NcsTool.ps1 compile -InputPath "C:\Scripts" -Recursive -LibraryLookup "C:\Includes" -Overwrite

# Decompile NCS to NSS
.\scripts\NcsTool.ps1 decompile -InputPath "script.ncs" -OutputPath "script.nss" -Game "k1"
.\scripts\NcsTool.ps1 decompile -InputPath "C:\NCS" -OutputPath "C:\Decompiled" -Recursive

# Compare two NCS files
.\scripts\NcsTool.ps1 compare -OriginalFile "original.ncs" -RoundTripFile "roundtrip.ncs" -CompareMode "bytecode" -Detailed
.\scripts\NcsTool.ps1 compare -OriginalFile "test.ncs" -RoundTripFile "test.rt.ncs" -CompareMode "both" -ShowOnly "both"

# Round-trip testing
.\scripts\NcsTool.ps1 roundtrip -InputPath "script.nss" -Game "k2"
.\scripts\NcsTool.ps1 roundtrip -InputPath "C:\Scripts" -Recursive -CompareMode "bytecode" -KeepIntermediate -StopOnFirstFailure

# Generate ScriptDefs.cs
.\scripts\NcsTool.ps1 generate-defs
```

The tool supports `-WhatIf` for dry-run testing, `-Verbose` for detailed output, and follows PowerShell best practices. It can process single files, multiple files, or entire directory trees recursively.

**CRITICAL: Ghidra MCP Usage for Andastra Code (Aurora/Eclipse/Infinity/Odyssey)**

When working on Andastra Engine code (anything in `src/Andastra/`), AI agents MUST:

1. **Use Ghidra MCP** for understanding original engine behavior:
   - Verify implementation faithfulness against original engine behavior
   - **ARCHITECTURAL POLICY: Conditional Logic vs Inheritance**:
     
     **‚ö†Ô∏è CRITICAL: NEW CODE ONLY - NO REFACTORING EXISTING CODE ‚ö†Ô∏è**
     
     **PREFERRED APPROACH: CONDITIONAL HANDLING (PRAGMATIC)**
     - For ALL **new** features, classes, and systems, prefer conditional logic (`if/else` or `switch` statements) within the same class/file rather than creating new inheritance hierarchies.
     - Use `GameType` (e.g., `K1`, `K2`, `NWN`) or `EngineType` identifiers to branch logic where behavior differs between games/engines.
     - This approach is more pragmatic for reverse engineering, as it keeps related logic for different games in one place and avoids "class explosion".
     - **Example pattern for new code**:
       ```csharp
       public void ProcessEvent(Event e)
       {
           // Common logic that works for all games...
           
           if (GameType == GameType.K2)
           {
               // KOTOR 2 specific behavior (swkotor2.exe: 0x004eb750)
           }
           else if (GameType == GameType.K1)
           {
               // KOTOR 1 specific behavior (swkotor.exe: 0x004af630)
           }
           // Common logic continues...
       }
       ```

     **üö´ ABSOLUTELY FORBIDDEN: REFACTORING EXISTING INHERITANCE STRUCTURES üö´**
     - **DO NOT** perform large, heavy refactors of existing three-tier inheritance structures.
     - **DO NOT** convert existing inheritance hierarchies to conditional logic.
     - **DO NOT** break existing class hierarchies, even if they use inheritance.
     - **DO NOT** rename or restructure existing base classes, engine classes, or game-specific classes.
     - **DO NOT** modify existing inheritance chains unless explicitly fixing a bug in that specific class.
     - **WHY**: Existing inheritance structures have many references throughout the codebase. Refactoring them would break hundreds of files and references.

     **EXISTING CODE POLICY: MAINTAIN AS-IS**
     - You will encounter a "Three-Tier Inheritance Structure" in many parts of the codebase:
       - **Tier 1: Base Classes (`Runtime.Games.Common`)**: Functionality identical across ALL engines.
       - **Tier 2: Engine Subclasses (`Runtime.Games.{Engine}`)**: Functionality shared within an engine family (e.g., Odyssey).
       - **Tier 3: Game Subclasses (`Runtime.Games.{Engine}.{Game}`)**: Game-specific overrides (e.g., K1 vs K2).
     - **For existing inheritance structures**:
       1. **Maintain them as-is** - do not refactor or convert to conditionals.
       2. **Work within the existing structure** - if you need to add game-specific behavior, add it to the appropriate tier level.
       3. **If adding a small fix** to an existing class that's part of an inheritance chain, you can use conditional logic WITHIN that class method if it avoids creating a new subclass, but do NOT change the class hierarchy itself.
       4. **NEVER** perform "mass refactors" to convert inheritance to conditionals.
       5. **NEVER** break existing references or rename existing classes in inheritance chains.

     **WHEN TO USE CONDITIONAL LOGIC:**
     - ‚úÖ Creating a **new** class or system from scratch
     - ‚úÖ Adding a **new** method to an existing class (use conditionals within the method)
     - ‚úÖ Implementing a **new** feature that doesn't exist yet
     - ‚úÖ Writing **new** code that needs to handle multiple games/engines

     **WHEN TO MAINTAIN INHERITANCE:**
     - ‚úÖ Working with existing classes that already use inheritance
     - ‚úÖ Fixing bugs in existing inheritance-based classes
     - ‚úÖ Adding features to existing inheritance-based systems
     - ‚úÖ Any code that already exists in the codebase

     **MANDATORY WORKFLOW FOR REVERSE ENGINEERING**:
     - Regardless of whether using conditionals or inheritance, the following reverse engineering steps are MANDATORY:
       1. Identify behavior by comparing across engines and games in Ghidra.
       2. Document findings in Ghidra for ALL relevant executables before implementing.
       3. In C# code, document the source of truth (e.g., `swkotor.exe: 0x...` or `swkotor2.exe: 0x...`) in comments near the conditional branch or method.
     
     **Example Conditional Logic (Preferred for New Code)**:
     ```csharp
     public void ProcessEvent(Event e)
     {
         // Common logic...
         
         if (GameType == GameType.K2)
         {
             // KOTOR 2 specific behavior (swkotor2.exe: 0x004eb750)
         }
         else if (GameType == GameType.K1)
         {
             // KOTOR 1 specific behavior (swkotor.exe: 0x004af630)
         }
     }
     ```

     **MANDATORY: In-Ghidra Documentation**: AI agents MUST document findings directly within Ghidra
     - Every analyzed function should have:
       - Descriptive function name
       - Function prototype with correct types
       - Comments explaining purpose and key details
       - Renamed variables and data labels
       - Cross-references documented where relevant

2. **Reference Documentation**:
   - Primary: `vendor/PyKotor/wiki/` for file format documentation
   - Secondary: `vendor/PyKotor/vendor/xoreos-docs/` for official BioWare specs
   - Implementation plan: `.cursor/plans/monogame_odyssey_engine_e8927e4a.plan.md`
   - Roadmap: `docs/engine_roadmap.md`

### Engine Architecture Principles

**No Game Assets**: Runtime loads from user-provided game installations. Never ship game assets.

### Engine API Implementation

When implementing NWScript engine functions:

1. **Use ScriptDefs**: Reference `Andastra.Common.Script.ScriptDefs` for function signatures
2. **Profile separation**: K1 has ~850 functions, K2 has ~950 functions. dragon age origins/dragon age 2/mass effect 1/2 and nwn: ee are unfinished and HIGH priorities.

### Clean-Room Process

- Implementation is derived from behavioral observation and specification documents
- **No code copying** from other implementations
- Match original engine behavior exactly where documented
- Document any deviations or improvements
- Avoid GPL/LGPL/AGPL dependencies in shipped runtime

### Testing Requirements

- NCS VM: deterministic unit tests for all opcodes
- Resource precedence: synthetic mini-installation fixtures
- Content decoding: golden-file tests
- Vertical slice: playable integration tests

### Performance Budgets

- Module load (warm): seconds, not minutes
- Frame rate: stable 60fps on midrange GPU
- Script budget: capped instructions per frame
- Memory: bounded caches with LRU eviction

### Definition of Done for Engine Work

A feature is complete when:

- Implementation matches original engine behavior
- Unit tests meticulously written, and passing for deterministic logic
- Integration with Andastra format parsers works
- C# 7.3 syntax or lower, 8+ isn't supported.
- Code compiles with no warnings
