# HoloPatcher.NET Rules and Conventions for AI LLM agents

## ⚠️ CRITICAL: Git Commit Requirement ⚠️

**MANDATORY FOR ALL AI AGENTS**: After making ANY changes to files in this repository, you MUST:

1. **Stage all modified files**: `git add <file1> <file2> ...` (or `git add .` for all changes)
2. **Commit with a descriptive message**: `git commit -m "type: descriptive message"`
3. **Verify the commit succeeded**: Check that `git commit` returns successfully with no errors

**This is NOT optional.** Do NOT summarize changes without committing them. Do NOT skip this step. Every code change, file modification, or configuration update MUST be committed before you consider the task complete.

**NEVER use `git add .` or `git add -A` to stage changes.** Always stage files individually. This is because we may have multiple agents working on multiple files simultaneously.

**Commit message format**: Use conventional commits format:

- `fix:` for bug fixes
- `feat:` for new features
- `refactor:` for code refactoring
- `docs:` for documentation changes
- `chore:` for maintenance tasks
- `test:` for test changes

Example: `git commit -m "fix: correct finalize job condition in workflow"`

Note: root-level .git is different repo than ./src/Andastra/.git

---

## Documentation

When creating ANY new `.md` files, always follow these guidelines:

- Always place within `docs`
- Never report on progression (changes and what still remains to be done).
- Exclusively provide public-facing documentation, something an end user will need to read if they want to either develop for Andastra.NET or work with it.

Please do not create .md documentation unless it delivers public-facing information or authoritative gameplay/platform references that an end user or developer genuinely needs for PyKotor or the games themselves.

## Helper Scripts

- Always place within `scripts`
- Should be idempotent and flexible enough to be used for a plethora of scenarios, not just whatever the task you're working on involves.
- Do not delete helper .py/.ps1/.sh scripts when you are finished with them; keep them in scripts folder

## File Organization

**CRITICAL: Repository Root Cleanup**

AI agents MUST maintain proper file organization in the repository root:

1. **Documentation Files**:
   - ALL `.md` documentation files (except `README.md`) MUST be placed in `./docs`
   - `README.md` is the ONLY markdown file allowed in the repository root
   - When creating new documentation, always place it in `./docs`
   - If you find documentation files in the root (other than `README.md`), move them to `./docs`

2. **Script Files**:
   - ALL script files (`.ps1`, `.sh`, `.py`, `.bat`, `.cmd`, etc.) MUST be placed in `./scripts`
   - When creating new scripts, always place them in `./scripts`
   - If you find script files in the root, move them to `./scripts`

3. **Root Directory**:
   - The root directory should only contain:
     - `README.md` (the only allowed markdown file in root)
     - Solution files (`.sln`)
     - Project configuration files (`.csproj`, `.props`, etc.)
     - Build artifacts and temporary files (as appropriate)
     - Essential configuration files (`.gitignore`, `.cursorrules`, etc.)

**When creating or moving files, always verify they are in the correct location according to these rules.**

## Cross-Platform Target Framework Requirements

**CRITICAL: All projects must be cross-platform compatible. Use platform-agnostic target frameworks only.**

- **DO use**: `net9.0`, `net8.0`, `net7.0` (no platform suffix)
- **DO NOT use**: `net9.0-windows`, `net9.0-linux`, `net9.0-macos` (platform-specific TFMs are forbidden)

This codebase must run on Windows, Linux, and macOS. Platform-specific TFMs break cross-platform compatibility and are not allowed under any circumstances.

## C# Language Version Requirements

**CRITICAL: The maximum C# language version allowed is 7.3. NEVER upgrade to C# 8.0 or higher.**

This is a hard requirement for .NET Framework 4.x compatibility. The following C# 8+ features are FORBIDDEN:

- Nullable reference types (`string?`, `object?`, etc.)
- Switch expressions
- Using declarations (must use `using` blocks)
- Default interface implementations
- Async streams
- Indices and ranges (`^1`, `..`)
- Null-coalescing assignment (`??=`)
- Pattern matching enhancements (property patterns, tuple patterns, positional patterns)
- Static local functions

When fixing code, convert C# 8+ syntax to C# 7.3 compatible alternatives, including but not limited to:

- `string?` → `string` (use `[CanBeNull]` attribute if needed and add `using JetBrains.Annotations;` if not already present)
- `value!` → `value` (remove null-forgiving operator)
- Switch expressions → switch statements
- `using var x = ...` → `using (var x = ...) { }`
- `namespace SomeNamespace;` → `namespace SomeNamespace { ... }`

## Incomplete/Temporary Code Marking

**CRITICAL: All incomplete code MUST use `TODO:` prefix for searchability.**

**Marking Patterns:**

- **STUB**: Method signature exists, throws `NotImplementedException` with context

  ```csharp
  // TODO: STUB - Implement ProcessData (swkotor2.exe: 0x004eb750)
  throw new NotImplementedException("ProcessData: Reverse engineering in progress");
  ```

- **PLACEHOLDER**: Temporary implementation that works but needs replacement

  ```csharp
  // TODO: PLACEHOLDER - Replace with full GFF serialization (swkotor2.exe: 0x005ac670)
  ```

- **SIMPLIFIED**: Working implementation missing features/optimizations

  ```csharp
  // TODO: SIMPLIFIED - Add A* pathfinding optimization for large areas
  ```

- **FIXME**: Known bug or incorrect behavior requiring fix

  ```csharp
  // TODO: FIXME - Memory leak when disposing resources, needs investigation
  ```

- **HACK**: Workaround that should be replaced with proper solution

  ```csharp
  // TODO: HACK - Using reflection until API is fixed
  ```

**Requirements:**

- ALL incomplete code MUST start with `TODO:` followed by type (STUB/PLACEHOLDER/SIMPLIFIED/FIXME/HACK)
- Include context: what needs doing, why incomplete, relevant addresses/refs
- For reverse-engineered code: include executable and function address
- Be specific: avoid vague comments like "fix this" or "placeholder"
- Public APIs: use XML docs (`/// <summary>`) to document incomplete methods

## NCS/NSS File Operations

The `scripts` directory contains a comprehensive unified PowerShell tool for all NCS/NSS file operations:

### NcsTool.ps1

Unified tool for all NCS (bytecode) and NSS (source) file operations. Supports multiple operations via subcommands:

**Operations:**

- `compile`: Compile NSS source files to NCS bytecode
- `decompile`: Decompile NCS bytecode files to NSS source
- `compare`: Compare two NCS files (bytecode and/or instructions)
- `roundtrip`: Perform round-trip testing (NSS -> NCS -> NSS -> NCS -> Compare)
- `generate-defs`: Generate ScriptDefs.cs from nwscript.nss files

**Examples:**

```powershell
# Compile NSS to NCS
.\scripts\NcsTool.ps1 compile -InputPath "script.nss" -Game "k2"
.\scripts\NcsTool.ps1 compile -InputPath "C:\Scripts" -Recursive -LibraryLookup "C:\Includes" -Overwrite

# Decompile NCS to NSS
.\scripts\NcsTool.ps1 decompile -InputPath "script.ncs" -OutputPath "script.nss" -Game "k1"
.\scripts\NcsTool.ps1 decompile -InputPath "C:\NCS" -OutputPath "C:\Decompiled" -Recursive

# Compare two NCS files
.\scripts\NcsTool.ps1 compare -OriginalFile "original.ncs" -RoundTripFile "roundtrip.ncs" -CompareMode "bytecode" -Detailed
.\scripts\NcsTool.ps1 compare -OriginalFile "test.ncs" -RoundTripFile "test.rt.ncs" -CompareMode "both" -ShowOnly "both"

# Round-trip testing
.\scripts\NcsTool.ps1 roundtrip -InputPath "script.nss" -Game "k2"
.\scripts\NcsTool.ps1 roundtrip -InputPath "C:\Scripts" -Recursive -CompareMode "bytecode" -KeepIntermediate -StopOnFirstFailure

# Generate ScriptDefs.cs
.\scripts\NcsTool.ps1 generate-defs
```

The tool supports `-WhatIf` for dry-run testing, `-Verbose` for detailed output, and follows PowerShell best practices. It can process single files, multiple files, or entire directory trees recursively.

**CRITICAL: Ghidra MCP Usage for Andastra Code (Aurora/Eclipse/Infinity/Odyssey)**

When working on Andastra Engine code (anything in `src/Andastra/`), AI agents MUST:

1. **Use Ghidra MCP** for understanding original engine behavior:
   - Verify implementation faithfulness against original engine behavior
   - **MANDATORY: Three-Tier Inheritance Structure - EXTREMELY METICULOUS AND VERY IMPORTANT**:
     
     **THE THREE-TIER INHERITANCE STRUCTURE IS CRITICAL FOR MAINTAINABILITY, CODE REUSE, AND ACCURATE REVERSE ENGINEERING DOCUMENTATION. FAILURE TO FOLLOW THIS STRUCTURE CORRECTLY WILL RESULT IN INCORRECT IMPLEMENTATIONS, DUPLICATED CODE, AND DIFFICULTY MAINTAINING ENGINE-SPECIFIC AND GAME-SPECIFIC DIFFERENCES.**
     
     **Tier 1: Base Classes (`Runtime.Games.Common`)**
     - **Purpose**: Contains functionality that is IDENTICAL across ALL engine families (Odyssey, Aurora, Eclipse, Infinity)
     - **Content**: Only truly universal functionality that exists in all engines with identical behavior
     - **MUST NOT contain**:
       - Any engine-specific function addresses (e.g., `swkotor2.exe: 0x004eb750`)
       - Any engine-specific implementation details
       - Any references to engine-specific file formats or systems
       - Any details that differ between ANY engines
       - Any game-specific details (e.g., KOTOR 1 vs KOTOR 2 differences)
     - **MUST ONLY contain**:
       - Abstract methods/properties that all engines share
       - Common initialization patterns (ONLY if identical across ALL engines)
       - Shared interfaces and contracts
       - Generic documentation that applies to ALL engines universally
       - Algorithmic/logical patterns that are identical across all engines
     
     **Tier 2: Engine Subclasses (`Runtime.Games.{Engine}`)**
     - **Purpose**: Contains functionality that is common within an engine family but differs between engine families
     - **Examples**: `OdysseyEventDispatcher`, `AuroraEventDispatcher`, `EclipseEventDispatcher`, `InfinityEventDispatcher`
     - **Content**: Functionality shared across all games within an engine family (e.g., KOTOR 1 and KOTOR 2 both use same event dispatch logic, but addresses differ between games)
     - **MUST contain**:
       - Engine family-specific function addresses (e.g., `swkotor.exe` and `swkotor2.exe` addresses in comments)
       - Engine family-specific implementation details
       - Engine family-specific file format references
       - Common patterns within the engine family
     - **MUST NOT contain**:
       - Game-specific differences (e.g., KOTOR 1 vs KOTOR 2 specific code paths)
       - Any details that are unique to a single game within the engine family
     
     **Tier 3: Game Subclasses (`Runtime.Games.{Engine}.{Game}`)**
     - **Purpose**: Contains functionality that is specific to individual games within an engine family
     - **Examples**: `Kotor1EventDispatcher : OdysseyEventDispatcher`, `Kotor2EventDispatcher : OdysseyEventDispatcher`
     - **Content**: Game-specific implementations where games in the same engine family differ
     - **MUST contain**:
       - Game-specific function addresses (e.g., `swkotor.exe: 0x004af630` for K1, `swkotor2.exe: 0x004dcfb0` for K2)
       - Game-specific implementation details
       - Game-specific constants, addresses, or configurations
       - Any code paths that differ between games in the same engine family
     
     **WHY THIS STRUCTURE IS CRITICAL**:
     1. **Accurate Documentation**: Function addresses and implementation details must be documented at the correct level (game-specific addresses in game subclasses, engine-specific in engine subclasses, never in base classes)
     2. **Code Reuse**: Common functionality is shared correctly without duplicating code
     3. **Maintainability**: Changes to engine-specific behavior affect only the engine subclass, changes to game-specific behavior affect only the game subclass
     4. **Reverse Engineering Accuracy**: When documenting from Ghidra, addresses and implementation details are placed at the correct abstraction level matching the actual executable they come from
     5. **Prevents Errors**: Incorrectly placing game-specific code in base classes or engine classes leads to incorrect implementations for other games/engines
     6. **Clear Separation of Concerns**: Each tier has a clear, well-defined responsibility that prevents confusion and implementation errors
     
     **MANDATORY WORKFLOW**:
     - **For Tier 1 (Base Classes)**:
       1. **NEVER implement or document base classes until ALL engines have been reverse engineered**
       2. Search for and analyze equivalent functions in ALL engines (swkotor.exe, swkotor2.exe, nwmain.exe, daorigins.exe, DragonAge2.exe, MassEffect.exe, MassEffect2.exe)
       3. Decompile and compare implementations across ALL engines to identify truly common patterns
       4. Document findings in Ghidra for ALL engines with function addresses and analysis
       5. Only after complete cross-engine analysis, identify what is truly common across ALL engines
       6. Implement base class with ONLY universal functionality (no engine-specific or game-specific details)
     
     - **For Tier 2 (Engine Subclasses)**:
       1. Search for and analyze equivalent functions in ALL games within the engine family (e.g., for Odyssey: swkotor.exe AND swkotor2.exe)
       2. Decompile and compare implementations across games in the engine family to identify engine-common patterns
       3. Document findings in Ghidra for ALL games in the engine family
       4. Identify what is common within the engine family (even if addresses differ between games)
       5. Implement engine subclass with engine-common functionality and document addresses for all games in the engine family
     
     - **For Tier 3 (Game Subclasses)**:
       1. Search Ghidra for functions specific to the individual game executable
       2. Decompile functions to understand game-specific implementation
       3. Document game-specific function addresses, constants, and implementation details
       4. Implement game subclass with game-specific functionality
       5. Override engine subclass methods only when game-specific behavior differs
     
     - **MANDATORY**: When finding ANY function in ANY engine, AI agents MUST:
       1. Identify which tier it belongs to by comparing across engines and games
       2. Search for similar/equivalent functions in ALL other engines and ALL games
       3. Decompile and compare implementations to determine the correct tier
       4. Document findings in Ghidra for ALL relevant executables before implementing
       5. Place code and documentation at the correct tier level
       6. Document inheritance structure clearly showing all three tiers
     
     - **Example Inheritance Structure**:
       ```
       BaseEventDispatcher (Runtime.Games.Common)
       ├── Common event dispatching interface and abstract methods
       ├── Generic event handling patterns (universal across all engines)
       └── NO engine-specific or game-specific details
       
       OdysseyEventDispatcher : BaseEventDispatcher (Runtime.Games.Odyssey)
       ├── Odyssey engine family common event dispatch logic
       ├── References to swkotor.exe and swkotor2.exe (both games)
       ├── Common event subtype mapping logic (same for both games)
       └── NO game-specific addresses or differences
       
       ├── Kotor1EventDispatcher : OdysseyEventDispatcher (Runtime.Games.Odyssey)
       │   ├── KOTOR 1 specific function addresses (swkotor.exe: 0x...)
       │   ├── KOTOR 1 specific constants and configurations
       │   └── Overrides only when K1 behavior differs from engine-common
       │
       └── Kotor2EventDispatcher : OdysseyEventDispatcher (Runtime.Games.Odyssey)
           ├── KOTOR 2 specific function addresses (swkotor2.exe: 0x...)
           ├── KOTOR 2 specific constants and configurations
           └── Overrides only when K2 behavior differs from engine-common
       ```

     - **MANDATORY**: When modifying ANY code in `src/Andastra/`, AI agents MUST:
       - **For Tier 1 (Base Classes)**:
         - MUST reverse engineer ALL engines first (Odyssey, Aurora, Eclipse, Infinity)
         - MUST compare implementations across ALL engines
         - MUST only document universal functionality (no engine-specific or game-specific details)
         - MUST NOT include ANY function addresses or executable-specific details
         - MUST NOT assume behavior is common without verifying across ALL engines
       
       - **For Tier 2 (Engine Subclasses)**:
         - MUST reverse engineer ALL games within the engine family first
         - MUST compare implementations across ALL games in the engine family
         - MUST document engine-common functionality with addresses from ALL games in the family
         - MUST NOT include game-specific differences (those belong in Tier 3)
         - MUST specify which executables the addresses come from (e.g., "swkotor.exe and swkotor2.exe")
       
       - **For Tier 3 (Game Subclasses)**:
         - MUST search Ghidra for functions in the specific game executable
         - MUST document game-specific function addresses, executable name, and context
         - MUST use consistent comment format matching the MonoGame API documentation pattern
         - MUST ALWAYS specify the source executable in comments (e.g., `swkotor.exe: 0x004af630` or `swkotor2.exe: 0x004dcfb0`)
         - MUST override engine subclass methods only when game-specific behavior is required
       
       - **PRIORITY**: When working on Tier 1 (base classes), prioritize reverse engineering Aurora and Eclipse engines FIRST (they are less documented than Odyssey)
   - **MANDATORY: In-Ghidra Documentation**: AI agents MUST document findings directly within Ghidra
     - **Documentation must be comprehensive**: Every analyzed function should have:
       - Descriptive function name (not `FUN_004eb750`, but `SaveGlobalVariables` or similar)
       - Function prototype with correct parameter types and return types
       - Comments explaining what the function does, its purpose, and key implementation details
       - Renamed variables and data labels that reflect their actual purpose
       - Cross-references documented where relevant

2. **Reference Documentation**:
   - Primary: `vendor/PyKotor/wiki/` for file format documentation
   - Secondary: `vendor/PyKotor/vendor/xoreos-docs/` for official BioWare specs
   - Implementation plan: `.cursor/plans/monogame_odyssey_engine_e8927e4a.plan.md`
   - Roadmap: `docs/engine_roadmap.md`

### Engine Architecture Principles

**No Game Assets**: Runtime loads from user-provided game installations. Never ship game assets.

### Engine API Implementation

When implementing NWScript engine functions:

1. **Use ScriptDefs**: Reference `Andastra.Common.Script.ScriptDefs` for function signatures
2. **Profile separation**: K1 has ~850 functions, K2 has ~950 functions. dragon age origins/dragon age 2/mass effect 1/2 and nwn: ee are unfinished and HIGH priorities.

### Clean-Room Process

- Implementation is derived from behavioral observation and specification documents
- **No code copying** from other implementations
- Match original engine behavior exactly where documented
- Document any deviations or improvements
- Avoid GPL/LGPL/AGPL dependencies in shipped runtime

### Testing Requirements

- NCS VM: deterministic unit tests for all opcodes
- Resource precedence: synthetic mini-installation fixtures
- Content decoding: golden-file tests
- Vertical slice: playable integration tests

### Performance Budgets

- Module load (warm): seconds, not minutes
- Frame rate: stable 60fps on midrange GPU
- Script budget: capped instructions per frame
- Memory: bounded caches with LRU eviction

### Definition of Done for Engine Work

A feature is complete when:

- Implementation matches original engine behavior
- Unit tests meticulously written, and passing for deterministic logic
- Integration with Andastra format parsers works
- C# 7.3 syntax or lower, 8+ isn't supported.
- Code compiles with no warnings
